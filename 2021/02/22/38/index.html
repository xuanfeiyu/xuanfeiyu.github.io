<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="JavaScipt," />










<meta name="description" content="作者：FY引用请标明出处  Part 4 · React 框架原理与实战模块一 · React 设计原理解密及核心源码解读任务一：React 基础回顾1.React 介绍 React 是一个用于构建用户界面的 Javascript 库，它只负责应用的视图层，帮助开发人员构架快速且交互式的 web 应用程序。React 使用组件的方式构建用户界面。  2.JSX 语法回顾(一) JSX 语法">
<meta property="og:type" content="article">
<meta property="og:title" content="学习笔记 ----- 【React 框架原理与实战】React 设计原理解密及核心源码解读">
<meta property="og:url" content="http://yoursite.com/2021/02/22/38/index.html">
<meta property="og:site_name" content="旋の飞羽">
<meta property="og:description" content="作者：FY引用请标明出处  Part 4 · React 框架原理与实战模块一 · React 设计原理解密及核心源码解读任务一：React 基础回顾1.React 介绍 React 是一个用于构建用户界面的 Javascript 库，它只负责应用的视图层，帮助开发人员构架快速且交互式的 web 应用程序。React 使用组件的方式构建用户界面。  2.JSX 语法回顾(一) JSX 语法">
<meta property="article:published_time" content="2021-02-21T16:00:00.000Z">
<meta property="article:modified_time" content="2021-02-22T04:10:01.642Z">
<meta property="article:author" content="FY">
<meta property="article:tag" content="JavaScipt">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/02/22/38/"/>





  <title>学习笔记 ----- 【React 框架原理与实战】React 设计原理解密及核心源码解读 | 旋の飞羽</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">旋の飞羽</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">人间值得，未来可期。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/02/22/38/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="FY">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="旋の飞羽">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">学习笔记 ----- 【React 框架原理与实战】React 设计原理解密及核心源码解读</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-22T00:00:00+08:00">
                2021-02-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index">
                    <span itemprop="name">前端</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>作者：FY<br>引用请标明出处</p>
</blockquote>
<h1 id="Part-4-·-React-框架原理与实战"><a href="#Part-4-·-React-框架原理与实战" class="headerlink" title="Part 4 · React 框架原理与实战"></a>Part 4 · React 框架原理与实战</h1><h2 id="模块一-·-React-设计原理解密及核心源码解读"><a href="#模块一-·-React-设计原理解密及核心源码解读" class="headerlink" title="模块一 · React 设计原理解密及核心源码解读"></a>模块一 · React 设计原理解密及核心源码解读</h2><h2 id="任务一：React-基础回顾"><a href="#任务一：React-基础回顾" class="headerlink" title="任务一：React 基础回顾"></a>任务一：React 基础回顾</h2><h3 id="1-React-介绍"><a href="#1-React-介绍" class="headerlink" title="1.React 介绍"></a>1.React 介绍</h3><ul>
<li>React 是一个用于构建用户界面的 Javascript 库，它只负责应用的视图层，帮助开发人员构架快速且交互式的 web 应用程序。React 使用组件的方式构建用户界面。</li>
</ul>
<h3 id="2-JSX-语法回顾-一"><a href="#2-JSX-语法回顾-一" class="headerlink" title="2.JSX 语法回顾(一)"></a>2.JSX 语法回顾(一)</h3><blockquote>
<p>JSX 语法</p>
</blockquote>
<ul>
<li>在 React 中使用JSX 语法描述用户界面，它是一种 JavaScript 语法扩展。</li>
<li>在 React 代码执行之前，Babel 会将 JSX 语法转换为标准的 JavaScript API。</li>
<li>JSX 语法就是一种语法糖，让开发人员使用更加舒服的代码构建用户界面。</li>
</ul>
<blockquote>
<p>在 JSX 中使用表达式</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">    firstName: <span class="string">'Harper'</span>,</span><br><span class="line">    lastName: <span class="string">'Perez'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatName</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> user.firstName + <span class="string">' '</span> + user.lastName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello,&#123;formatName(user)&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<p>JSX 本身其实也是一种表达式，将它赋值给变量，当做参数传入，作为返回值都可以。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGreeting</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(user) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello,&#123;formatName(user)&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello,Stranger.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>属性</p>
</blockquote>
<p>如果属性值为 JavaScript 表达式，需要加引号，属性名称推荐采用驼峰式命名法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">greeting</span>=<span class="string">"hello"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>如果属性值为 JavaScript 表达式，属性值外面加大括号。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="comment">// 注意大括号外面不能加引号，JSX 会将引号中的内容识别为字符串而不是表达式</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>JSX 单标记必须闭合</p>
</blockquote>
<p>如果是 JSX 是单标记，必须闭合，否则报错。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>/&gt;</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>className</p>
</blockquote>
<p>为 JSX 标记添加类名需要使用 className，而不是 class</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span> <span class="attr">className</span>=<span class="string">"rounded"</span>/&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>JSX 自动展开数组</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const ary &#x3D; [&lt;p&gt;哈哈&lt;&#x2F;p&gt;, &lt;p&gt;呵呵&lt;&#x2F;p&gt;, &lt;p&gt;嘿嘿&lt;&#x2F;p&gt;];</span><br><span class="line">const element &#x3D; (</span><br><span class="line">	&lt;div&gt;&#123;ary&#125;&lt;&#x2F;div&gt;</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F; 解析后</span><br><span class="line">&#x2F;*</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">		&lt;p&gt;哈哈&lt;&#x2F;p&gt;</span><br><span class="line">		&lt;p&gt;呵呵&lt;&#x2F;p&gt;</span><br><span class="line">		&lt;p&gt;嘿嘿&lt;&#x2F;p&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>三元运算</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; boolean ? &lt;div&gt;Hello React&lt;&#x2F;div&gt; : null &#125;</span><br><span class="line">&#123; boolean &amp;&amp; &lt;div&gt;Hello React&lt;&#x2F;div&gt; &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>循环</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const persons &#x3D; [&#123;</span><br><span class="line">  id: 1,</span><br><span class="line">  name: &#39;张三&#39;,</span><br><span class="line">  age: 20</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  id: 2,</span><br><span class="line">  name: &#39;李四&#39;,</span><br><span class="line">  age: 15</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  id: 3,</span><br><span class="line">  name: &#39;王五&#39;,</span><br><span class="line">  age: 22</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &#123; persons.map(person &#x3D;&gt; &lt;li key&#x3D;&#123;person.id&#125;&gt; &#123;person.name&#125; &#123;person.age&#125; &lt;&#x2F;li&gt;) &#125;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>

<h3 id="3-JSX-语法回顾-二"><a href="#3-JSX-语法回顾-二" class="headerlink" title="3.JSX 语法回顾(二)"></a>3.JSX 语法回顾(二)</h3><blockquote>
<p>事件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x2F;* 第一个参数即是事件对象 不需传递 *&#x2F;&#125;</span><br><span class="line">&lt;button onClick&#x3D;&#123;this.eventHandler&#125;&gt;按钮&lt;&#x2F;button&gt;</span><br><span class="line">&#123;&#x2F;* 需要传递事件对象 *&#x2F;&#125;</span><br><span class="line">&lt;button onClick&#x3D;&#123;e&#x3D;&gt;this.eventHandler(&#39;arg&#39;,e)&#125;&gt;按钮&lt;&#x2F;button&gt;</span><br><span class="line">&#123;&#x2F;* 最后一个参数即是事件对象 不需传递 *&#x2F;&#125;</span><br><span class="line">&lt;button onClick&#x3D;&#123;this.eventHandler.bind(null, &#39;arg&#39;)&#125;&gt;按钮&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">constructor () &#123;</span><br><span class="line">  this.eventHandler &#x3D; this.eventHandler.bind(this)</span><br><span class="line">&#125;</span><br><span class="line">eventHandler () &#123;&#125;</span><br><span class="line">&lt;button onClick&#x3D;&#123;this.eventHandler&#125;&gt;按钮&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>样式</p>
</blockquote>
<ul>
<li>行内样式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const style &#x3D; &#123;width: 200, height: 200, backgroundColor: &#39;red&#39;&#125;;</span><br><span class="line">    return &lt;div style&#x3D;&#123;style&#125;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>外链样式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Button.js</span><br><span class="line">import styles from &#39;.&#x2F;Button.module.css&#39;;</span><br><span class="line">class Button extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;button className&#x3D;&#123;styles.error&#125;&gt;Error Button&lt;&#x2F;button&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>全局样式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#39;.&#x2F;styles.css&#39;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ref 属性</p>
</blockquote>
<ul>
<li>createRef</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Input extends Component &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super()</span><br><span class="line">    this.inputRef &#x3D; React.createRef()</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; ref&#x3D;&#123;this.inputRef&#125; &#x2F;&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; console.log(this.inputRef.current)&#125;&gt; button &lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Input extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; ref&#x3D;&#123;input &#x3D;&gt; (this.input &#x3D; input)&#125; &#x2F;&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; console.log(this.input)&#125;&gt;button&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>ref 字符串</li>
</ul>
<p>不推荐使用，在严格模式下报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Input extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; ref&#x3D;&quot;username&quot; &#x2F;&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; console.log(this.refs.username)&#125;&gt;button&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取组件实例</p>
</blockquote>
<p>点击按钮让 input 文本框获取焦点。</p>
<p>input 文本框以及让文本框获取焦点的方法定义在 Input 组件中，在 App 组件中引入 Input 组件，按钮定义在 App 组件中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Input.js</span><br><span class="line">class Input extends Component &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super()</span><br><span class="line">    this.inputRef &#x3D; React.createRef()</span><br><span class="line">    this.focusInput &#x3D; this.focusInput.bind(this)</span><br><span class="line">  &#125;</span><br><span class="line">  focusInput() &#123;</span><br><span class="line">    this.inputRef.current.focus()</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; ref&#x3D;&#123;this.inputRef&#125; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; App.js</span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super()</span><br><span class="line">    this.InputComponentRef &#x3D; React.createRef()</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className&#x3D;&quot;App&quot;&gt;</span><br><span class="line">        &lt;Input ref&#x3D;&#123;this.InputComponentRef&#125; &#x2F;&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; this.InputComponentRef.current.focusInput()&#125;&gt;button&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-组件回顾-一"><a href="#4-组件回顾-一" class="headerlink" title="4.组件回顾(一)"></a>4.组件回顾(一)</h3><blockquote>
<p>什么是组件</p>
</blockquote>
<p>React 是基于组件的方式进行用户界面开发的. 组件可以理解为对页面中某一块区域的封装。</p>
<blockquote>
<p>创建组件</p>
</blockquote>
<ul>
<li>创建类组件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &#39;react&#39;;</span><br><span class="line">class App extends Component &#123;</span><br><span class="line">    render () &#123;</span><br><span class="line">        return &lt;div&gt;Hello, 我是类组件&lt;&#x2F;div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>创建函数组件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const Person &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">     return &lt;div&gt;Hello, 我是函数型组件&lt;&#x2F;div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ol>
<li>组件名称首字母必须大写，用以区分组件和普通标签。</li>
<li>jsx语法外层必须有一个根元素</li>
</ol>
<blockquote>
<p>组件 props</p>
</blockquote>
<ul>
<li>props 传递数据</li>
</ul>
<p>在调用组件时可以向组件内部传递数据，在组件中可以通过 props 对象获取外部传递进来的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;Person name&#x3D;&quot;乔治&quot; age&#x3D;&quot;20&quot;&#x2F;&gt;</span><br><span class="line">&lt;Person name&#x3D;&quot;玛丽&quot; age&#x3D;&quot;10&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 类组件</span><br><span class="line">class Person extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;姓名：&#123;this.props.name&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">        &lt;h4&gt;年龄：&#123;this.props.age&#125;&lt;&#x2F;h4&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 函数组件</span><br><span class="line">const Person &#x3D; props &#x3D;&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h3&gt;姓名：&#123;props.name&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">      &lt;h4&gt;年龄：&#123;props.age&#125;&lt;&#x2F;h4&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ol>
<li>props 对象中存储的数据是只读的，不能在组件内部被修改。</li>
<li>当 props 数据源中的数据被修改后，组件中的接收到的 props 数据会被同步更新。( 数据驱动DOM )</li>
</ol>
<blockquote>
<p>设置 props 默认值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line">    static defaultProps &#x3D; &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function ThemedButton(props) &#123;</span><br><span class="line">&#125;</span><br><span class="line">ThemedButton.defaultProps &#x3D; &#123;</span><br><span class="line">  theme: &quot;secondary&quot;,</span><br><span class="line">  label: &quot;Button Text&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>组件 children</p>
</blockquote>
<p>通过 props.children 属性可以获取到在调用组件时填充到组件标签内部的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Person&gt;组件内部的内容&lt;&#x2F;Person&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const Person &#x3D; (props) &#x3D;&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">    	&lt;div&gt;&#123;props.children&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>单向数据流</p>
</blockquote>
<ol>
<li><p>在React中, 关于数据流动有一条原则, 就是单向数据流动, 自顶向下, 从父组件到子组件.</p>
</li>
<li><p>单向数据流特性要求我们共享数据要放置在上层组件中.</p>
</li>
<li><p>子组件通过调用父组件传递过来的方法更改数据.</p>
</li>
<li><p>当数据发生更改时, React会重新渲染组件树.</p>
</li>
<li><p>单向数据流使组件之间的数据流动变得可预测. 使得定位程序错误变得简单.</p>
</li>
</ol>
<blockquote>
<p>类组件状态 state</p>
</blockquote>
<ul>
<li>定义组件状态</li>
</ul>
<p>类组件除了能够从外部 (props) 接收状态数据以外还可以拥有自己的状态 (state)，此状态在组件内部可以被更新，状态更新 DOM 更新。</p>
<p>组件内部的状态数据被存储在组件类中的 state 属性中，state 属性值为对象类型，属性名称固定不可更改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    super()</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      person: &#123; name: &#39;张三&#39;, age: 20 &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;this.state.person.name&#125;</span><br><span class="line">        &#123;this.state.person.age&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>更改组件状态</li>
</ul>
<p>state 状态对象中的数据不可直接更改，如果直接更改 DOM 不会被更新，要更改 state 状态数据需要使用 setState方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      person: &#123; name: &#39;张三&#39;, age: 20 &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    this.changePerson &#x3D; this.changePerson.bind(this)</span><br><span class="line">  &#125;</span><br><span class="line">	changePerson () &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      person: &#123;</span><br><span class="line">        name: &#39;李四&#39;,</span><br><span class="line">        age: 15</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;this.state.person.name&#125;</span><br><span class="line">        &#123;this.state.person.age&#125;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.changePerson&#125;&gt;按钮&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>双向数据绑定</li>
</ul>
<p>双向数据绑定是指，组件类中更新了状态，DOM 状态同步更新，DOM 更改了状态，组件类中同步更新。组件 &lt;=&gt; 视图。</p>
<p>要实现双向数据绑定需要用到表单元素和 state 状态对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      name: &quot;张三&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    this.nameChanged &#x3D; this.nameChanged.bind(this)</span><br><span class="line">  &#125;</span><br><span class="line">  nameChanged (event) &#123;</span><br><span class="line">    this.setState(&#123;name: event.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;&#123;this.state.name&#125;&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;Person name&#x3D;&#123;this.state.name&#125; changed&#x3D;&#123;this.nameChanged&#125;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const Person &#x3D; props &#x3D;&gt; &#123;</span><br><span class="line">	return &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;props.name&#125; onChange&#x3D;&#123;props.changed&#125;&#x2F;&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-组件回顾-二"><a href="#5-组件回顾-二" class="headerlink" title="5.组件回顾(二)"></a>5.组件回顾(二)</h3><blockquote>
<p>类组件生命周期函数</p>
</blockquote>
<p>在组件完成更新之前需要做某种逻辑或者计算，就需要用到快照</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate(prevProps, prevState, snapshot) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>getSnapshotBeforeUpdate 方法会在组件完成更新之前执行，用于执行某种逻辑或计算，返回值可以在 componentDidUpdate 方法中的第三个参数中获取，就是说在组件更新之后可以拿到这个值再去做其他事情。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">  return &#39;snapshot&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Context </p>
</blockquote>
<p>通过 Context 可以跨层级传递数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; userContext.js</span><br><span class="line">import React from &quot;react&quot;</span><br><span class="line"></span><br><span class="line">const userContext &#x3D; React.createContext(&quot;default value&quot;)</span><br><span class="line">const UserProvider &#x3D; userContext.Provider</span><br><span class="line">const UserConsumer &#x3D; userContext.Consumer</span><br><span class="line"></span><br><span class="line">export &#123; UserProvider, UserConsumer &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; App.js</span><br><span class="line">import &#123; UserProvider &#125; from &quot;.&#x2F;userContext&quot;</span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;UserProvider value&#x3D;&quot;Hello React Context&quot;&gt;</span><br><span class="line">        &lt;A &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;UserProvider&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; C.js</span><br><span class="line">import &#123; UserConsumer &#125; from &quot;.&#x2F;userContext&quot;</span><br><span class="line"></span><br><span class="line">export class C extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;UserConsumer&gt;</span><br><span class="line">          &#123;username &#x3D;&gt; &#123;</span><br><span class="line">            return &lt;div&gt;&#123;username&#125;&lt;&#x2F;div&gt;</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        &lt;&#x2F;UserConsumer&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>context 的另一种用法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; userContext.js</span><br><span class="line">export default userContext</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; C.js</span><br><span class="line">import userContext from &quot;.&#x2F;userContext&quot;</span><br><span class="line"></span><br><span class="line">export class C extends Component &#123;</span><br><span class="line">  static contextType &#x3D; userContext</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;this.context&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-表单回顾"><a href="#6-表单回顾" class="headerlink" title="6.表单回顾"></a>6.表单回顾</h3><blockquote>
<p>表单</p>
</blockquote>
<ul>
<li>受控表单</li>
</ul>
<p>表单控件中的值由组件的 state 对象来管理，state对象中存储的值和表单控件中的值时同步状态的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this.state &#x3D; &#123; username: &quot;&quot; &#125;</span><br><span class="line">    this.nameChanged &#x3D; this.nameChanged.bind(this)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  nameChanged (e) &#123;</span><br><span class="line">    this.setState(&#123;username: e.target.value&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        &lt;p&gt;&#123;this.state.username&#125;&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; value&#x3D;&#123;this.state.username&#125; onChange&#x3D;&#123;this.nameChanged&#125;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>非受控表单</li>
</ul>
<p>表单元素的值由 DOM 元素本身管理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class App extends Component &#123;</span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this.onSubmit &#x3D; this.onSubmit.bind(this)</span><br><span class="line">  &#125;</span><br><span class="line">  onSubmit(e) &#123;</span><br><span class="line">    console.log(this.username.value)</span><br><span class="line">    e.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line">  render(</span><br><span class="line">    &lt;form onSubmit&#x3D;&#123;this.onSubmit&#125;&gt;</span><br><span class="line">      &lt;input type&#x3D;&quot;text&quot; ref&#x3D;&#123;username &#x3D;&gt; this.username &#x3D; username&#125;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-路由回顾"><a href="#7-路由回顾" class="headerlink" title="7.路由回顾"></a>7.路由回顾</h3><blockquote>
<p>路由</p>
</blockquote>
<p>url地址与组件之间的对应关系，访问不同的url地址显示不同的组件。</p>
<p>下载：<code>npm install react-router-dom</code></p>
<ul>
<li>路由基本使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; App.js</span><br><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#123; BrowserRouter as Router, Route, Link &#125; from &#39;react-router-dom&#39;;</span><br><span class="line">function Index() &#123;</span><br><span class="line">	return &lt;div&gt;首页&lt;&#x2F;div&gt;;</span><br><span class="line">&#125;</span><br><span class="line">function News() &#123;</span><br><span class="line">	return &lt;div&gt;新闻&lt;&#x2F;div&gt;;</span><br><span class="line">&#125;</span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Router&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Link to&#x3D;&quot;&#x2F;index&quot;&gt;首页&lt;&#x2F;Link&gt;</span><br><span class="line">        &lt;Link to&#x3D;&quot;&#x2F;news&quot;&gt;新闻&lt;&#x2F;Link&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Route path&#x3D;&quot;&#x2F;index&quot; component&#x3D;&#123;Index&#125;&#x2F;&gt;</span><br><span class="line">        &lt;Route path&#x3D;&quot;&#x2F;news&quot; component&#x3D;&#123;News&#125;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;Router&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>路由嵌套</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function News(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Link to&#x3D;&#123;&#96;$&#123;props.match.url&#125;&#x2F;company&#96;&#125;&gt;公司新闻&lt;&#x2F;Link&gt;</span><br><span class="line">        &lt;Link to&#x3D;&#123;&#96;$&#123;props.match.url&#125;&#x2F;industry&#96;&#125;&gt;行业新闻&lt;&#x2F;Link&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Route path&#x3D;&#123;&#96;$&#123;props.match.path&#125;&#x2F;company&#96;&#125; component&#x3D;&#123;CompanyNews&#125; &#x2F;&gt;</span><br><span class="line">        &lt;Route path&#x3D;&#123;&#96;$&#123;props.match.path&#125;&#x2F;industry&#96;&#125; component&#x3D;&#123;IndustryNews&#125;&#x2F;&gt;  </span><br><span class="line">      &lt;&#x2F;div&gt;	</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function CompanyNews() &#123;</span><br><span class="line">	return &lt;div&gt;公司新闻&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br><span class="line">function IndustryNews() &#123;</span><br><span class="line">	return &lt;div&gt;行业新闻&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>路由传参</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">import url from &#39;url&#39;;</span><br><span class="line">class News extends Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      list: [&#123;</span><br><span class="line">        id: 1,</span><br><span class="line">        title: &#39;新闻1&#39;</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        id: 2,</span><br><span class="line">        title: &#39;新闻2&#39;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;新闻列表组件&lt;&#x2F;div&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          this.state.list.map((item, index) &#x3D;&gt; &#123;</span><br><span class="line">            return (</span><br><span class="line">              &lt;li key&#x3D;&#123;index&#125;&gt;</span><br><span class="line">                &lt;Link to&#x3D;&#123;&#96;&#x2F;detail?id&#x3D;$&#123;item.id&#125;&#96;&#125;&gt;&#123;item.title&#125;&lt;&#x2F;Link&gt;</span><br><span class="line">              &lt;&#x2F;li&gt;</span><br><span class="line">            );</span><br><span class="line">          &#125;)</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Detail extends Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">  &#125;</span><br><span class="line">	const &#123; query &#125; &#x3D; url.parse(this.props.location.search, true);</span><br><span class="line">	console.log(query); &#x2F;&#x2F; &#123;id: 1&#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;新闻详情&lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>路由重定向</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; Redirect &#125; from &#39;react-router-dom&#39;;</span><br><span class="line"></span><br><span class="line">class Login extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    if (this.state.isLogin) &#123;</span><br><span class="line">      return &lt;Redirect to&#x3D;&quot;&#x2F;&quot;&#x2F;&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="任务二：VirtualDOM-及-Diff-算法"><a href="#任务二：VirtualDOM-及-Diff-算法" class="headerlink" title="任务二：VirtualDOM 及 Diff 算法"></a>任务二：VirtualDOM 及 Diff 算法</h2><h3 id="1-课程介绍"><a href="#1-课程介绍" class="headerlink" title="1.课程介绍"></a>1.课程介绍</h3><p>略</p>
<h3 id="2-JSX-到底是什么"><a href="#2-JSX-到底是什么" class="headerlink" title="2.JSX 到底是什么"></a>2.JSX 到底是什么</h3><p>使用 React 就一定会写 JSX，JSX 到底是什么呢？它是一种 JavaScript 语法的扩展，React 使用它来描述用户界面长成什么样子。虽然它看起来非常像 HTML，但它确实是 JavaScript 。在 React 代码执行之前，Babel 会对将 JSX 编译为 React API.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className&#x3D;&quot;container&quot;&gt;</span><br><span class="line">  &lt;h3&gt;Hello React&lt;&#x2F;h3&gt;</span><br><span class="line">  &lt;p&gt;React is great &lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  &quot;div&quot;,</span><br><span class="line">  &#123;</span><br><span class="line">    className: &quot;container&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  React.createElement(&quot;h3&quot;, null, &quot;Hello React&quot;),</span><br><span class="line">  React.createElement(&quot;p&quot;, null, &quot;React is great&quot;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>从两种语法对比来看，JSX 语法的出现是为了让 React 开发人员编写用户界面代码更加轻松。</p>
<p><a href="https://babeljs.io/repl" target="_blank" rel="noopener">Babel REPL</a></p>
<h3 id="3-VirtualDOM-介绍"><a href="#3-VirtualDOM-介绍" class="headerlink" title="3.VirtualDOM 介绍"></a>3.VirtualDOM 介绍</h3><blockquote>
<p>DOM 操作问题</p>
</blockquote>
<p>在现代 web 应用程序中使用 JavaScript 操作 DOM 是必不可少的，但遗憾的是它比其他大多数 JavaScript 操作要慢的多。</p>
<p>大多数 JavaScript 框架对于 DOM 的更新远远超过其必须进行的更新，从而使得这种缓慢操作变得更糟。</p>
<p>例如假设你有包含十个项目的列表，你仅仅更改了列表中的第一项，大多数 JavaScript 框架会重建整个列表，这比必要的工作要多十倍。</p>
<p>更新效率低下已经成为严重问题，为了解决这个问题，React 普及了一种叫做 Virtual DOM 的东西，Virtual DOM 出现的目的就是为了提高 JavaScript 操作 DOM 对象的效率。</p>
<blockquote>
<p>什么是 Virtual DOM</p>
</blockquote>
<p>在 React 中，每个 DOM 对象都有一个对应的 Virtual DOM 对象，它是 DOM 对象的 JavaScript 对象表现形式，其实就是使用 JavaScript 对象来描述 DOM 对象信息，比如 DOM 对象的类型是什么，它身上有哪些属性，它拥有哪些子元素。</p>
<p>可以把 Virtual DOM 对象理解为 DOM 对象的副本，但是它不能直接显示在屏幕上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className&#x3D;&quot;container&quot;&gt;</span><br><span class="line">  &lt;h3&gt;Hello React&lt;&#x2F;h3&gt;</span><br><span class="line">  &lt;p&gt;React is great &lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: &quot;div&quot;,</span><br><span class="line">  props: &#123; className: &quot;container&quot; &#125;,</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      type: &quot;h3&quot;,</span><br><span class="line">      props: null,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          type: &quot;text&quot;,</span><br><span class="line">          props: &#123;</span><br><span class="line">            textContent: &quot;Hello React&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      type: &quot;p&quot;,</span><br><span class="line">      props: null,</span><br><span class="line">      children: [</span><br><span class="line">        &#123;</span><br><span class="line">          type: &quot;text&quot;,</span><br><span class="line">          props: &#123;</span><br><span class="line">            textContent: &quot;React is great&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Virtual DOM 如何提升效率</p>
</blockquote>
<p>精准找出发生变化的 DOM 对象，只更新发生变化的部分。</p>
<p>在 React 第一次创建 DOM 对象后，会为每个 DOM 对象创建其对应的 Virtual DOM 对象，在 DOM 对象发生更新之前，React 会先更新所有的 Virtual DOM 对象，然后 React 会将更新后的 Virtual DOM 和 更新前的 Virtual DOM 进行比较，从而找出发生变化的部分，React 会将发生变化的部分更新到真实的 DOM 对象中，React 仅更新必要更新的部分。</p>
<p>Virtual DOM 对象的更新和比较仅发生在内存中，不会在视图中渲染任何内容，所以这一部分的性能损耗成本是微不足道的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;container&quot;&gt;</span><br><span class="line">	&lt;p&gt;Hello React&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;container&quot;&gt;</span><br><span class="line">	&lt;p&gt;Hello Angular&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const before &#x3D; &#123;</span><br><span class="line">  type: &quot;div&quot;,</span><br><span class="line">  props: &#123; id: &quot;container&quot; &#125;,</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      type: &quot;p&quot;,</span><br><span class="line">      props: null,</span><br><span class="line">      children: [</span><br><span class="line">        &#123; type: &quot;text&quot;, props: &#123; textContent: &quot;Hello React&quot; &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const after &#x3D; &#123;</span><br><span class="line">  type: &quot;div&quot;,</span><br><span class="line">  props: &#123; id: &quot;container&quot; &#125;,</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      type: &quot;p&quot;,</span><br><span class="line">      props: null,</span><br><span class="line">      children: [</span><br><span class="line">        &#123; type: &quot;text&quot;, props: &#123; textContent: &quot;Hello Angular&quot; &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-创建-VirtualDOM-对象-一"><a href="#4-创建-VirtualDOM-对象-一" class="headerlink" title="4.创建 VirtualDOM 对象(一)"></a>4.创建 VirtualDOM 对象(一)</h3><p>略</p>
<h3 id="5-创建-VirtualDOM-对象-二"><a href="#5-创建-VirtualDOM-对象-二" class="headerlink" title="5.创建 VirtualDOM 对象(二)"></a>5.创建 VirtualDOM 对象(二)</h3><p>在 React 代码执行前，JSX 会被 Babel 转换为 React.createElement 方法的调用，在调用 createElement 方法时会传入元素的类型，元素的属性，以及元素的子元素，createElement 方法的返回值为构建好的 Virtual DOM 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type: &quot;div&quot;,</span><br><span class="line">  props: null,</span><br><span class="line">  children: [&#123;type: &quot;text&quot;, props: &#123;textContent: &quot;Hello&quot;&#125;&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 创建 Virtual DOM</span><br><span class="line"> * @param &#123;string&#125; type 类型</span><br><span class="line"> * @param &#123;object | null&#125; props 属性</span><br><span class="line"> * @param  &#123;createElement[]&#125; children 子元素</span><br><span class="line"> * @return &#123;object&#125; Virtual DOM</span><br><span class="line"> *&#x2F;</span><br><span class="line">function createElement (type, props, ...children) &#123;</span><br><span class="line">	return &#123;</span><br><span class="line">    type,</span><br><span class="line">    props,</span><br><span class="line">    children</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 createElement 方法的第三个参数开始就都是子元素了，在定义 createElement 方法时，通过 <code>...children</code> 将所有的子元素放置到 children 数组中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const virtualDOM &#x3D; (</span><br><span class="line">  &lt;div className&#x3D;&quot;container&quot;&gt;</span><br><span class="line">    &lt;h1&gt;你好 Tiny React&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;h2&gt;(编码必杀技)&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      嵌套1 &lt;div&gt;嵌套 1.1&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;h3&gt;(观察: 这个将会被改变)&lt;&#x2F;h3&gt;</span><br><span class="line">    &#123;2 &#x3D;&#x3D; 1 &amp;&amp; &lt;div&gt;如果2和1相等渲染当前内容&lt;&#x2F;div&gt;&#125;</span><br><span class="line">    &#123;2 &#x3D;&#x3D; 2 &amp;&amp; &lt;div&gt;2&lt;&#x2F;div&gt;&#125;</span><br><span class="line">    &lt;span&gt;这是一段内容&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;button onClick&#x3D;&#123;() &#x3D;&gt; alert(&quot;你好&quot;)&#125;&gt;点击我&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;h3&gt;这个将会被删除&lt;&#x2F;h3&gt;</span><br><span class="line">    2, 3</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">)</span><br><span class="line">console.log(virtualDOM)</span><br></pre></td></tr></table></figure>

<p>通过以上代码测试，发现返回的 Virtual DOM 存在一些问题，第一个问题是文本节点被直接放入到了数组中</p>
<p>而我们期望是文本节点应该是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">children: [</span><br><span class="line">  &#123;</span><br><span class="line">    type: &quot;text&quot;,</span><br><span class="line">    props: &#123;</span><br><span class="line">      textContent: &quot;React is great&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>通过以下代码对 Virtual DOM 进行改造，重新构建 Virtual DOM。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将原有 children 拷贝一份 不要在原有数组上进行操作</span></span><br><span class="line"><span class="keyword">const</span> childElements = [].concat(...children).map(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 判断 child 是否是对象类型</span></span><br><span class="line">  <span class="keyword">if</span> (child <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果是 什么都不需要做 直接返回即可</span></span><br><span class="line">    <span class="keyword">return</span> child</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不是对象就是文本 手动调用 createElement 方法将文本转换为 Virtual DOM</span></span><br><span class="line">    <span class="keyword">return</span> createElement(<span class="string">"text"</span>, &#123; <span class="attr">textContent</span>: child &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  type,</span><br><span class="line">  props,</span><br><span class="line">  children: childElements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过观察返回的 Virtual DOM，文本节点已经被转化成了对象类型的 Virtual DOM，但是布尔值也被当做文本节点被转化了，在 JSX 中，如果 Virtual DOM 被转化为了布尔值或者null，是不应该被更新到真实 DOM 中的，所以接下来要做的事情就是清除 Virtual DOM 中的布尔值和null。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 由于 map 方法无法从数据中刨除元素, 所以此处将 map 方法更改为 reduce 方法</span><br><span class="line">const childElements &#x3D; [].concat(...children).reduce((result, child) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 判断子元素类型 刨除 null true false</span><br><span class="line">  if (child !&#x3D; null &amp;&amp; child !&#x3D; false &amp;&amp; child !&#x3D; true) &#123;</span><br><span class="line">    if (child instanceof Object) &#123;</span><br><span class="line">      result.push(child)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      result.push(createElement(&quot;text&quot;, &#123; textContent: child &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 将需要保留的 Virtual DOM 放入 result 数组</span><br><span class="line">  return result</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure>

<p>在 React 组件中，可以通过 props.children 获取子元素，所以还需要将子元素存储在 props 对象中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  type,</span><br><span class="line">  props: <span class="built_in">Object</span>.assign(&#123; <span class="attr">children</span>: childElements &#125;, props),</span><br><span class="line">  children: childElements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-普通-VirtualDOM-对象转化为真实-DOM-对象"><a href="#6-普通-VirtualDOM-对象转化为真实-DOM-对象" class="headerlink" title="6.普通 VirtualDOM 对象转化为真实 DOM 对象"></a>6.普通 VirtualDOM 对象转化为真实 DOM 对象</h3><p>通过调用 render 方法可以将 Virtual DOM 对象更新为真实 DOM 对象。</p>
<p>在更新之前需要确定是否存在旧的 Virtual DOM，如果存在需要比对差异，如果不存在可以直接将 Virtual DOM 转换为 DOM 对象。 </p>
<p>目前先只考虑不存在旧的 Virtual DOM 的情况，就是说先直接将 Virtual DOM 对象更新为真实 DOM 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; render.js</span><br><span class="line">export default function render(virtualDOM, container, oldDOM &#x3D; container.firstChild) &#123;</span><br><span class="line">  &#x2F;&#x2F; 在 diff 方法内部判断是否需要对比 对比也好 不对比也好 都在 diff 方法中进行操作  </span><br><span class="line">  diff(virtualDOM, container, oldDOM)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; diff.js</span><br><span class="line">import mountElement from &quot;.&#x2F;mountElement&quot;</span><br><span class="line"></span><br><span class="line">export default function diff(virtualDOM, container, oldDOM) &#123;</span><br><span class="line">  &#x2F;&#x2F; 判断 oldDOM 是否存在</span><br><span class="line">  if (!oldDOM) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果不存在 不需要对比 直接将 Virtual DOM 转换为真实 DOM</span><br><span class="line">    mountElement(virtualDOM, container)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在进行 virtual DOM 转换之前还需要确定 Virtual DOM 的类 Component VS Native Element。</p>
<p>类型不同需要做不同的处理 如果是 Native Element 直接转换。</p>
<p>如果是组件 还需要得到组件实例对象 通过组件实例对象获取组件返回的 virtual DOM 然后再进行转换。</p>
<p>目前先只考虑 Native Element 的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; mountElement.js</span><br><span class="line">import mountNativeElement from &quot;.&#x2F;mountNativeElement&quot;</span><br><span class="line"></span><br><span class="line">export default function mountElement(virtualDOM, container) &#123;</span><br><span class="line">  &#x2F;&#x2F; 通过调用 mountNativeElement 方法转换 Native Element</span><br><span class="line">  mountNativeElement(virtualDOM, container)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; mountNativeElement.js</span><br><span class="line">import createDOMElement from &quot;.&#x2F;createDOMElement&quot;</span><br><span class="line"></span><br><span class="line">export default function mountNativeElement(virtualDOM, container) &#123;</span><br><span class="line">  const newElement &#x3D; createDOMElement(virtualDOM)</span><br><span class="line">  container.appendChild(newElement)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; createDOMElement.js</span><br><span class="line">import mountElement from &quot;.&#x2F;mountElement&quot;</span><br><span class="line">import updateElementNode from &quot;.&#x2F;updateElementNode&quot;</span><br><span class="line"></span><br><span class="line">export default function createDOMElement(virtualDOM) &#123;</span><br><span class="line">  let newElement &#x3D; null</span><br><span class="line">  if (virtualDOM.type &#x3D;&#x3D;&#x3D; &quot;text&quot;) &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建文本节点</span><br><span class="line">    newElement &#x3D; document.createTextNode(virtualDOM.props.textContent)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建元素节点</span><br><span class="line">    newElement &#x3D; document.createElement(virtualDOM.type)</span><br><span class="line">    &#x2F;&#x2F; 更新元素属性</span><br><span class="line">    updateElementNode(newElement, virtualDOM)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 递归渲染子节点</span><br><span class="line">  virtualDOM.children.forEach(child &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 因为不确定子元素是 NativeElement 还是 Component 所以调用 mountElement 方法进行确定</span><br><span class="line">    mountElement(child, newElement)</span><br><span class="line">  &#125;)</span><br><span class="line">  return newElement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-为-DOM-对象添加属性"><a href="#7-为-DOM-对象添加属性" class="headerlink" title="7.为 DOM 对象添加属性"></a>7.为 DOM 对象添加属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; createDOMElement.js</span><br><span class="line">&#x2F;&#x2F; 看看节点类型是文本类型还是元素类型</span><br><span class="line">if (virtualDOM.type &#x3D;&#x3D;&#x3D; &quot;text&quot;) &#123;</span><br><span class="line">  &#x2F;&#x2F; 创建文本节点 设置节点内容</span><br><span class="line">  newElement &#x3D; document.createTextNode(virtualDOM.props.textContent)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; 根据 Virtual DOM type 属性值创建 DOM 元素</span><br><span class="line">  newElement &#x3D; document.createElement(virtualDOM.type)</span><br><span class="line">  &#x2F;&#x2F; 为元素设置属性</span><br><span class="line">  updateElementNode(newElement, virtualDOM)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">export default function updateElementNode(element, virtualDOM) &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取要解析的 VirtualDOM 对象中的属性对象</span><br><span class="line">  const newProps &#x3D; virtualDOM.props</span><br><span class="line">  &#x2F;&#x2F; 将属性对象中的属性名称放到一个数组中并循环数组</span><br><span class="line">  Object.keys(newProps).forEach(propName &#x3D;&gt; &#123;</span><br><span class="line">    const newPropsValue &#x3D; newProps[propName]</span><br><span class="line">    &#x2F;&#x2F; 考虑属性名称是否以 on 开头 如果是就表示是个事件属性 onClick -&gt; click</span><br><span class="line">    if (propName.slice(0, 2) &#x3D;&#x3D;&#x3D; &quot;on&quot;) &#123;</span><br><span class="line">      const eventName &#x3D; propName.toLowerCase().slice(2)</span><br><span class="line">      element.addEventListener(eventName, newPropsValue)</span><br><span class="line">      &#x2F;&#x2F; 如果属性名称是 value 或者 checked 需要通过 [] 的形式添加</span><br><span class="line">    &#125; else if (propName &#x3D;&#x3D;&#x3D; &quot;value&quot; || propName &#x3D;&#x3D;&#x3D; &quot;checked&quot;) &#123;</span><br><span class="line">      element[propName] &#x3D; newPropsValue</span><br><span class="line">      &#x2F;&#x2F; 刨除 children 因为它是子元素 不是属性</span><br><span class="line">    &#125; else if (propName !&#x3D;&#x3D; &quot;children&quot;) &#123;</span><br><span class="line">      &#x2F;&#x2F; className 属性单独处理 不直接在元素上添加 class 属性是因为 class 是 JavaScript 中的关键字</span><br><span class="line">      if (propName &#x3D;&#x3D;&#x3D; &quot;className&quot;) &#123;</span><br><span class="line">        element.setAttribute(&quot;class&quot;, newPropsValue)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 普通属性</span><br><span class="line">        element.setAttribute(propName, newPropsValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-组件渲染之区分函数组件和类组件"><a href="#8-组件渲染之区分函数组件和类组件" class="headerlink" title="8.组件渲染之区分函数组件和类组件"></a>8.组件渲染之区分函数组件和类组件</h3><blockquote>
<p>函数组件</p>
</blockquote>
<p>在渲染组件之前首先要明确的是，组件的 Virtual DOM 类型值为函数，函数组件和类组件都是这样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 原始组件</span><br><span class="line">const Heart &#x3D; () &#x3D;&gt; &lt;span&gt;&amp;hearts;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Heart &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 组件的 Virtual DOM</span><br><span class="line">&#123;</span><br><span class="line">  type: f function() &#123;&#125;,</span><br><span class="line">  props: &#123;&#125;</span><br><span class="line">  children: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在渲染组件时，要先将 Component 与 Native Element 区分开，如果是 Native Element 可以直接开始渲染，如果是组件，特别处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; mountElement.js</span><br><span class="line">export default function mountElement(virtualDOM, container) &#123;</span><br><span class="line">  &#x2F;&#x2F; 无论是类组件还是函数组件 其实本质上都是函数 </span><br><span class="line">  &#x2F;&#x2F; 如果 Virtual DOM 的 type 属性值为函数 就说明当前这个 Virtual DOM 为组件</span><br><span class="line">  if (isFunction(virtualDOM)) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果是组件 调用 mountComponent 方法进行组件渲染</span><br><span class="line">    mountComponent(virtualDOM, container)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    mountNativeElement(virtualDOM, container)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Virtual DOM 是否为函数类型</span><br><span class="line">export function isFunction(virtualDOM) &#123;</span><br><span class="line">  return virtualDOM &amp;&amp; typeof virtualDOM.type &#x3D;&#x3D;&#x3D; &quot;function&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 mountComponent 方法中再进行函数组件和类型的区分，然后再分别进行处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; mountComponent.js</span><br><span class="line">import mountNativeElement from &quot;.&#x2F;mountNativeElement&quot;</span><br><span class="line"></span><br><span class="line">export default function mountComponent(virtualDOM, container) &#123;</span><br><span class="line">  &#x2F;&#x2F; 存放组件调用后返回的 Virtual DOM 的容器</span><br><span class="line">  let nextVirtualDOM &#x3D; null</span><br><span class="line">  &#x2F;&#x2F; 区分函数型组件和类组件</span><br><span class="line">  if (isFunctionalComponent(virtualDOM)) &#123;</span><br><span class="line">    &#x2F;&#x2F; 函数组件 调用 buildFunctionalComponent 方法处理函数组件</span><br><span class="line">    nextVirtualDOM &#x3D; buildFunctionalComponent(virtualDOM)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 类组件</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 判断得到的 Virtual Dom 是否是组件</span><br><span class="line">  if (isFunction(nextVirtualDOM)) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果是组件 继续调用 mountComponent 解剖组件</span><br><span class="line">    mountComponent(nextVirtualDOM, container)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果是 Navtive Element 就去渲染</span><br><span class="line">    mountNativeElement(nextVirtualDOM, container)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Virtual DOM 是否为函数型组件</span><br><span class="line">&#x2F;&#x2F; 条件有两个: 1. Virtual DOM 的 type 属性值为函数 2. 函数的原型对象中不能有render方法</span><br><span class="line">&#x2F;&#x2F; 只有类组件的原型对象中有render方法 </span><br><span class="line">export function isFunctionalComponent(virtualDOM) &#123;</span><br><span class="line">  const type &#x3D; virtualDOM &amp;&amp; virtualDOM.type</span><br><span class="line">  return (</span><br><span class="line">    type &amp;&amp; isFunction(virtualDOM) &amp;&amp; !(type.prototype &amp;&amp; type.prototype.render)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 函数组件处理 </span><br><span class="line">function buildFunctionalComponent(virtualDOM) &#123;</span><br><span class="line">  &#x2F;&#x2F; 通过 Virtual DOM 中的 type 属性获取到组件函数并调用</span><br><span class="line">  &#x2F;&#x2F; 调用组件函数时将 Virtual DOM 对象中的 props 属性传递给组件函数 这样在组件中就可以通过 props 属性获取数据了</span><br><span class="line">  &#x2F;&#x2F; 组件返回要渲染的 Virtual DOM</span><br><span class="line">  return virtualDOM &amp;&amp; virtualDOM.type(virtualDOM.props || &#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>类组件</p>
</blockquote>
<p>类组件本身也是 Virtual DOM，可以通过 Virtual DOM 中的 type 属性值确定当前要渲染的组件是类组件还是函数组件。</p>
<p>在确定当前要渲染的组件为类组件以后，需要实例化类组件得到类组件实例对象，通过类组件实例对象调用类组件中的 render 方法，获取组件要渲染的 Virtual DOM。</p>
<p>类组件需要继承 Component 父类，子类需要通过 super 方法将自身的 props 属性传递给 Component 父类，父类会将 props 属性挂载为父类属性，子类继承了父类，自己本身也就自然拥有props属性了。这样做的好处是当 props 发生更新后，父类可以根据更新后的 props 帮助子类更新视图。</p>
<p>假设以下代码就是我们要渲染的类组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Alert extends TinyReact.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将 props 传递给父类 子类继承父类的 props 子类自然就有 props 数据了</span><br><span class="line">    &#x2F;&#x2F; 否则 props 仅仅是 constructor 函数的参数而已</span><br><span class="line">    &#x2F;&#x2F; 将 props 传递给父类的好处是 当 props 发生更改时 父类可以帮助更新 props 更新组件视图</span><br><span class="line">    super(props)</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      title: &quot;default title&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;&#123;this.state.title&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;p&gt;&#123;this.props.message&#125;&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TinyReact.render(&lt;Alert message&#x3D;&quot;Hello React&quot; &#x2F;&gt;, root)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Component.js 父类 Component 实现</span><br><span class="line">export default class Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    this.props &#x3D; props</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 mountComponent 方法中通过调用 buildStatefulComponent 方法得到类组件要渲染的 Virtual DOM</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; mountComponent.js</span><br><span class="line">export default function mountComponent(virtualDOM, container) &#123;</span><br><span class="line">  let nextVirtualDOM &#x3D; null</span><br><span class="line">  &#x2F;&#x2F; 区分函数型组件和类组件</span><br><span class="line">  if (isFunctionalComponent(virtualDOM)) &#123;</span><br><span class="line">    &#x2F;&#x2F; 函数组件</span><br><span class="line">    nextVirtualDOM &#x3D; buildFunctionalComponent(virtualDOM)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 类组件</span><br><span class="line">    nextVirtualDOM &#x3D; buildStatefulComponent(virtualDOM)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 判断得到的 Virtual Dom 是否是组件</span><br><span class="line">  if (isFunction(nextVirtualDOM)) &#123;</span><br><span class="line">    mountComponent(nextVirtualDOM, container)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    mountNativeElement(nextVirtualDOM, container)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 处理类组件</span><br><span class="line">function buildStatefulComponent(virtualDOM) &#123;</span><br><span class="line">  &#x2F;&#x2F; 实例化类组件 得到类组件实例对象 并将 props 属性传递进类组件</span><br><span class="line">  const component &#x3D; new virtualDOM.type(virtualDOM.props)</span><br><span class="line">  &#x2F;&#x2F; 调用类组件中的render方法得到要渲染的 Virtual DOM</span><br><span class="line">  const nextVirtualDOM &#x3D; component.render()</span><br><span class="line">  &#x2F;&#x2F; 返回要渲染的 Virtual DOM</span><br><span class="line">  return nextVirtualDOM</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-组件渲染之函数组件"><a href="#9-组件渲染之函数组件" class="headerlink" title="9.组件渲染之函数组件"></a>9.组件渲染之函数组件</h3><p>略</p>
<h3 id="10-组件渲染之函数组件-prop-参数处理"><a href="#10-组件渲染之函数组件-prop-参数处理" class="headerlink" title="10.组件渲染之函数组件 prop 参数处理"></a>10.组件渲染之函数组件 prop 参数处理</h3><p>略</p>
<h3 id="11-组件渲染之类组件"><a href="#11-组件渲染之类组件" class="headerlink" title="11.组件渲染之类组件"></a>11.组件渲染之类组件</h3><p>略</p>
<h3 id="12-组件渲染之类组件-props-处理"><a href="#12-组件渲染之类组件-props-处理" class="headerlink" title="12.组件渲染之类组件 props 处理"></a>12.组件渲染之类组件 props 处理</h3><p>略</p>
<h3 id="13-更新-DOM-元素之-VirtualDOM-对比-节点类型相同的情况-一"><a href="#13-更新-DOM-元素之-VirtualDOM-对比-节点类型相同的情况-一" class="headerlink" title="13.更新 DOM 元素之 VirtualDOM 对比(节点类型相同的情况)(一)"></a>13.更新 DOM 元素之 VirtualDOM 对比(节点类型相同的情况)(一)</h3><p>在进行 Virtual DOM 比对时，需要用到更新后的 Virtual DOM 和更新前的 Virtual DOM，更新后的 Virtual DOM 目前我们可以通过 render 方法进行传递，现在的问题是更新前的 Virtual DOM 要如何获取呢？</p>
<p>对于更新前的 Virtual DOM，对应的其实就是已经在页面中显示的真实 DOM 对象。既然是这样，那么我们在创建真实DOM对象时，就可以将 Virtual DOM 添加到真实 DOM 对象的属性中。在进行 Virtual DOM 对比之前，就可以通过真实 DOM 对象获取其对应的 Virtual DOM 对象了，其实就是通过render方法的第三个参数获取的，container.firstChild。</p>
<p>在创建真实 DOM 对象时为其添加对应的 Virtual DOM 对象</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; mountElement.js</span><br><span class="line">import mountElement from &quot;.&#x2F;mountElement&quot;</span><br><span class="line"></span><br><span class="line">export default function mountNativeElement(virtualDOM, container) &#123;</span><br><span class="line">  &#x2F;&#x2F; 将 Virtual DOM 挂载到真实 DOM 对象的属性中 方便在对比时获取其 Virtual DOM</span><br><span class="line">  newElement._virtualDOM &#x3D; virtualDOM</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Virtual DOM 类型相同，如果是元素节点，就对比元素节点属性是否发生变化，如果是文本节点就对比文本节点内容是否发生变化</p>
<p>要实现对比，需要先从已存在 DOM 对象中获取其对应的 Virtual DOM 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; diff.js</span><br><span class="line">&#x2F;&#x2F; 获取未更新前的 Virtual DOM</span><br><span class="line">const oldVirtualDOM &#x3D; oldDOM &amp;&amp; oldDOM._virtualDOM</span><br></pre></td></tr></table></figure>

<p>判断 oldVirtualDOM 是否存在， 如果存在则继续判断要对比的 Virtual DOM 类型是否相同，如果类型相同判断节点类型是否是文本，如果是文本节点对比，就调用 updateTextNode 方法，如果是元素节点对比就调用 setAttributeForElement 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; diff.js</span><br><span class="line">else if (oldVirtualDOM &amp;&amp; virtualDOM.type &#x3D;&#x3D;&#x3D; oldVirtualDOM.type) &#123;</span><br><span class="line">  if (virtualDOM.type &#x3D;&#x3D;&#x3D; &quot;text&quot;) &#123;</span><br><span class="line">    &#x2F;&#x2F; 文本节点 对比文本内容是否发生变化</span><br><span class="line">    updateTextNode(virtualDOM, oldVirtualDOM, oldDOM)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 元素节点 对比元素属性是否发生变化</span><br><span class="line">    setAttributeForElement(oldDOM, virtualDOM, oldVirtualDOM)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>updateTextNode 方法用于对比文本节点内容是否发生变化，如果发生变化则更新真实 DOM 对象中的内容，既然真实 DOM 对象发生了变化，还要将最新的 Virtual DOM 同步给真实 DOM 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function updateTextNode(virtualDOM, oldVirtualDOM, oldDOM) &#123;</span><br><span class="line">  &#x2F;&#x2F; 如果文本节点内容不同</span><br><span class="line">  if (virtualDOM.props.textContent !&#x3D;&#x3D; oldVirtualDOM.props.textContent) &#123;</span><br><span class="line">    &#x2F;&#x2F; 更新真实 DOM 对象中的内容</span><br><span class="line">    oldDOM.textContent &#x3D; virtualDOM.props.textContent</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 同步真实 DOM 对应的 Virtual DOM</span><br><span class="line">  oldDOM._virtualDOM &#x3D; virtualDOM</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setAttributeForElement 方法用于设置/更新元素节点属性</p>
<p>思路是先分别获取更新后的和更新前的 Virtual DOM 中的 props 属性，循环新 Virtual DOM 中的 props 属性，通过对比看一下新 Virtual DOM 中的属性值是否发生了变化，如果发生变化 需要将变化的值更新到真实 DOM 对象中</p>
<p>再循环未更新前的 Virtual DOM 对象，通过对比看看新的 Virtual DOM 中是否有被删除的属性，如果存在删除的属性 需要将 DOM 对象中对应的属性也删除掉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; updateNodeElement.js</span><br><span class="line">export default function updateNodeElement(</span><br><span class="line">  newElement,</span><br><span class="line">  virtualDOM,</span><br><span class="line">  oldVirtualDOM &#x3D; &#123;&#125;</span><br><span class="line">) &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取节点对应的属性对象</span><br><span class="line">  const newProps &#x3D; virtualDOM.props || &#123;&#125;</span><br><span class="line">  const oldProps &#x3D; oldVirtualDOM.props || &#123;&#125;</span><br><span class="line">  Object.keys(newProps).forEach(propName &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取属性值</span><br><span class="line">    const newPropsValue &#x3D; newProps[propName]</span><br><span class="line">    const oldPropsValue &#x3D; oldProps[propName]</span><br><span class="line">    if (newPropsValue !&#x3D;&#x3D; oldPropsValue) &#123;</span><br><span class="line">      &#x2F;&#x2F; 判断属性是否是否事件属性 onClick -&gt; click</span><br><span class="line">      if (propName.slice(0, 2) &#x3D;&#x3D;&#x3D; &quot;on&quot;) &#123;</span><br><span class="line">        &#x2F;&#x2F; 事件名称</span><br><span class="line">        const eventName &#x3D; propName.toLowerCase().slice(2)</span><br><span class="line">        &#x2F;&#x2F; 为元素添加事件</span><br><span class="line">        newElement.addEventListener(eventName, newPropsValue)</span><br><span class="line">        &#x2F;&#x2F; 删除原有的事件的事件处理函数</span><br><span class="line">        if (oldPropsValue) &#123;</span><br><span class="line">          newElement.removeEventListener(eventName, oldPropsValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else if (propName &#x3D;&#x3D;&#x3D; &quot;value&quot; || propName &#x3D;&#x3D;&#x3D; &quot;checked&quot;) &#123;</span><br><span class="line">        newElement[propName] &#x3D; newPropsValue</span><br><span class="line">      &#125; else if (propName !&#x3D;&#x3D; &quot;children&quot;) &#123;</span><br><span class="line">        if (propName &#x3D;&#x3D;&#x3D; &quot;className&quot;) &#123;</span><br><span class="line">          newElement.setAttribute(&quot;class&quot;, newPropsValue)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          newElement.setAttribute(propName, newPropsValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  &#x2F;&#x2F; 判断属性被删除的情况</span><br><span class="line">  Object.keys(oldProps).forEach(propName &#x3D;&gt; &#123;</span><br><span class="line">    const newPropsValue &#x3D; newProps[propName]</span><br><span class="line">    const oldPropsValue &#x3D; oldProps[propName]</span><br><span class="line">    if (!newPropsValue) &#123;</span><br><span class="line">      &#x2F;&#x2F; 属性被删除了</span><br><span class="line">      if (propName.slice(0, 2) &#x3D;&#x3D;&#x3D; &quot;on&quot;) &#123;</span><br><span class="line">        const eventName &#x3D; propName.toLowerCase().slice(2)</span><br><span class="line">        newElement.removeEventListener(eventName, oldPropsValue)</span><br><span class="line">      &#125; else if (propName !&#x3D;&#x3D; &quot;children&quot;) &#123;</span><br><span class="line">        newElement.removeAttribute(propName)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上对比的仅仅是最上层元素，上层元素对比完成以后还需要递归对比子元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">else if (oldVirtualDOM &amp;&amp; virtualDOM.type &#x3D;&#x3D;&#x3D; oldVirtualDOM.type) &#123;</span><br><span class="line">    &#x2F;&#x2F; 递归对比 Virtual DOM 的子元素</span><br><span class="line">    virtualDOM.children.forEach((child, i) &#x3D;&gt; &#123;</span><br><span class="line">      diff(child, oldDOM, oldDOM.childNodes[i])</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="14-更新-DOM-元素之-VirtualDOM-对比-节点类型相同的情况-二"><a href="#14-更新-DOM-元素之-VirtualDOM-对比-节点类型相同的情况-二" class="headerlink" title="14.更新 DOM 元素之 VirtualDOM 对比(节点类型相同的情况)(二)"></a>14.更新 DOM 元素之 VirtualDOM 对比(节点类型相同的情况)(二)</h3><p>略</p>
<h3 id="15-图示-VirtualDOM-比对"><a href="#15-图示-VirtualDOM-比对" class="headerlink" title="15.图示 VirtualDOM 比对"></a>15.图示 VirtualDOM 比对</h3><p>略</p>
<h3 id="16-更新-DOM-元素之-VirtualDOM-对比-节点类型不相同的情况"><a href="#16-更新-DOM-元素之-VirtualDOM-对比-节点类型不相同的情况" class="headerlink" title="16.更新 DOM 元素之 VirtualDOM 对比(节点类型不相同的情况)"></a>16.更新 DOM 元素之 VirtualDOM 对比(节点类型不相同的情况)</h3><p>当对比的元素节点类型不同时，就不需要继续对比了，直接使用新的 Virtual DOM 创建 DOM 对象，用新的 DOM 对象直接替换旧的 DOM 对象。当前这种情况要将组件刨除，组件要被单独处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; diff.js</span><br><span class="line">else if (</span><br><span class="line">  &#x2F;&#x2F; 如果 Virtual DOM 类型不一样</span><br><span class="line">  virtualDOM.type !&#x3D;&#x3D; oldVirtualDOM.type &amp;&amp;</span><br><span class="line">  &#x2F;&#x2F; 并且 Virtual DOM 不是组件 因为组件要单独进行处理</span><br><span class="line">  typeof virtualDOM.type !&#x3D;&#x3D; &quot;function&quot;</span><br><span class="line">) &#123;</span><br><span class="line">  &#x2F;&#x2F; 根据 Virtual DOM 创建真实 DOM 元素</span><br><span class="line">  const newDOMElement &#x3D; createDOMElement(virtualDOM)</span><br><span class="line">  &#x2F;&#x2F; 用创建出来的真实 DOM 元素 替换旧的 DOM 元素</span><br><span class="line">  oldDOM.parentNode.replaceChild(newDOMElement, oldDOM)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="17-更新-DOM-元素之删除节点"><a href="#17-更新-DOM-元素之删除节点" class="headerlink" title="17.更新 DOM 元素之删除节点"></a>17.更新 DOM 元素之删除节点</h3><p>删除节点发生在节点更新以后并且发生在同一个父节点下的所有子节点身上。</p>
<p>在节点更新完成以后，如果旧节点对象的数量多于新 VirtualDOM 节点的数量，就说明有节点需要被删除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取就节点的数量</span><br><span class="line">let oldChildNodes &#x3D; oldDOM.childNodes</span><br><span class="line">&#x2F;&#x2F; 如果旧节点的数量多于要渲染的新节点的长度</span><br><span class="line">if (oldChildNodes.length &gt; virtualDOM.children.length) &#123;</span><br><span class="line">  for (</span><br><span class="line">    let i &#x3D; oldChildNodes.length - 1;</span><br><span class="line">    i &gt; virtualDOM.children.length - 1;</span><br><span class="line">    i--</span><br><span class="line">  ) &#123;</span><br><span class="line">    oldDOM.removeChild(oldChildNodes[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-setState-方法实现类组件更新-一"><a href="#18-setState-方法实现类组件更新-一" class="headerlink" title="18.setState 方法实现类组件更新(一)"></a>18.setState 方法实现类组件更新(一)</h3><p>以下代码是要更新状态的类组件，在类组件的 state 对象中有默认的 title 状态，点击 change title 按钮调用 handleChange 方法，在 handleChange 方法中调用 this.setState 方法更改 title 的状态值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Alert extends TinyReact.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props)</span><br><span class="line">    this.state &#x3D; &#123;</span><br><span class="line">      title: &quot;default title&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 更改 handleChange 方法中的 this 指向 让 this 指向类实例对象</span><br><span class="line">    this.handleChange &#x3D; this.handleChange.bind(this)</span><br><span class="line">  &#125;</span><br><span class="line">  handleChange() &#123;</span><br><span class="line">    &#x2F;&#x2F; 调用父类中的 setState 方法更改状态</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      title: &quot;changed title&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;&#123;this.state.title&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;p&gt;&#123;this.props.message&#125;&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.handleChange&#125;&gt;change title&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>setState 方法是定义在父类 Component 中的，该方法的作用是更改子类的 state，产生一个全新的 state 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Component.js</span><br><span class="line">export default class Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    this.props &#x3D; props</span><br><span class="line">  &#125;</span><br><span class="line">  setState (state) &#123;</span><br><span class="line">    &#x2F;&#x2F; setState 方法被子类调用 此处this指向子类实例对象</span><br><span class="line">    &#x2F;&#x2F; 所以改变的是子类的 state 对象</span><br><span class="line">    this.state &#x3D; Object.assign(&#123;&#125;, this.state, state)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在子类已经可以调用父类的 setState 方法更改状态值了，当组件的 state 对象发生更改时，要调用 render 方法更新组件视图。</p>
<p>在更新组件之前，要使用更新的 Virtual DOM 对象和未更新的 Virtual DOM 进行对比找出更新的部分，达到 DOM 最小化操作的目的。</p>
<p>在 setState 方法中可以通过调用 this.render 方法获取更新后的 Virtual DOM，由于 setState 方法被子类调用，this 指向子类，所以此处调用的是子类的 render 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Component.js</span><br><span class="line">setState(state) &#123;</span><br><span class="line">  &#x2F;&#x2F; setState 方法被子类调用 此处this指向子类</span><br><span class="line">  &#x2F;&#x2F; 所以改变的是子类的 state</span><br><span class="line">  this.state &#x3D; Object.assign(&#123;&#125;, this.state, state)</span><br><span class="line">  &#x2F;&#x2F; 通过调用 render 方法获取最新的 Virtual DOM</span><br><span class="line">  let virtualDOM &#x3D; this.render()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要实现对比，还需要获取未更新前的 Virtual DOM，按照之前的经验，我们可以从 DOM 对象中获取其对应的 Virtual  DOM 对象，未更新前的 DOM 对象实际上就是现在在页面中显示的 DOM 对象，我们只要能获取到这个 DOM 对象就可以获取到其对应的 Virtual DOM 对象了。</p>
<p>页面中的 DOM 对象要怎样获取呢？页面中的 DOM 对象是通过 mountNativeElement 方法挂载到页面中的，所以我们只需要在这个方法中调用 Component 类中的方法就可以将 DOM 对象保存在 Component 类中了。在子类调用 setState 方法的时候，在 setState 方法中再调用另一个获取 DOM 对象的方法就可以获取到之前保存的 DOM 对象了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Component.js</span><br><span class="line">&#x2F;&#x2F; 保存 DOM 对象的方法</span><br><span class="line">setDOM(dom) &#123;</span><br><span class="line">  this._dom &#x3D; dom</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 获取 DOM 对象的方法</span><br><span class="line">getDOM() &#123;</span><br><span class="line">  return this._dom</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们要研究一下在 mountNativeElement 方法中如何才能调用到 setDOM 方法，要调用 setDOM 方法，必须要得到类的实例对象，所以目前的问题就是如何在 mountNativeElement 方法中得到类的实例对象，这个类指的不是Component类，因为我们在代码中并不是直接实例化的Component类，而是实例化的它的子类，由于子类继承了父类，所以在子类的实例对象中也是可以调用到 setDOM 方法的。</p>
<p>mountNativeElement 方法接收最新的 Virtual DOM 对象，如果这个 Virtual DOM 对象是类组件产生的，在产生这个 Virtual DOM 对象时一定会先得到这个类的实例对象，然后再调用实例对象下面的 render 方法进行获取。我们可以在那个时候将类组件实例对象添加到 Virtual DOM 对象的属性中，而这个 Virtual DOM 对象最终会传递给 mountNativeElement  方法，这样我们就可以在 mountNativeElement 方法中获取到组件的实例对象了，既然类组件的实例对象获取到了，我们就可以调用 setDOM 方法了。</p>
<p>在 buildClassComponent 方法中为 Virtual DOM 对象添加 component 属性， 值为类组件的实例对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function buildClassComponent(virtualDOM) &#123;</span><br><span class="line">  const component &#x3D; new virtualDOM.type(virtualDOM.props)</span><br><span class="line">  const nextVirtualDOM &#x3D; component.render()</span><br><span class="line">  nextVirtualDOM.component &#x3D; component</span><br><span class="line">  return nextVirtualDOM</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 mountNativeElement 方法中获取组件实例对象，通过实例调用调用 setDOM 方法保存 DOM 对象，方便在对比时通过它获取它的 Virtual DOM 对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default function mountNativeElement(virtualDOM, container) &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取组件实例对象</span><br><span class="line">  const component &#x3D; virtualDOM.component</span><br><span class="line">  &#x2F;&#x2F; 如果组件实例对象存在</span><br><span class="line">  if (component) &#123;</span><br><span class="line">    &#x2F;&#x2F; 保存 DOM 对象</span><br><span class="line">    component.setDOM(newElement)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来在 setState 方法中就可以调用 getDOM 方法获取 DOM 对象了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setState(state) &#123;</span><br><span class="line">  this.state &#x3D; Object.assign(&#123;&#125;, this.state, state)</span><br><span class="line">  let virtualDOM &#x3D; this.render()</span><br><span class="line">  &#x2F;&#x2F; 获取页面中正在显示的 DOM 对象 通过它可以获取其对象的 Virtual DOM 对象</span><br><span class="line">  let oldDOM &#x3D; this.getDOM()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在更新前的 Virtual DOM 对象和更新后的 Virtual DOM 对象就都已经获取到了，接下来还要获取到真实 DOM 对象父级容器对象，因为在调用 diff 方法进行对比的时候需要用到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setState(state) &#123;</span><br><span class="line">  this.state &#x3D; Object.assign(&#123;&#125;, this.state, state)</span><br><span class="line">  let virtualDOM &#x3D; this.render()</span><br><span class="line">  let oldDOM &#x3D; this.getDOM()</span><br><span class="line">  &#x2F;&#x2F; 获取真实 DOM 对象父级容器对象</span><br><span class="line">  let container &#x3D; oldDOM.parentNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就可以调用 diff 方法进行比对了，比对后会按照我们之前写好的逻辑进行 DOM 对象更新，我们就可以在页面中看到效果了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">setState(state) &#123;</span><br><span class="line">    this.state &#x3D; Object.assign(&#123;&#125;, this.state, state)</span><br><span class="line">    let virtualDOM &#x3D; this.render()</span><br><span class="line">    let oldDOM &#x3D; this.getDOM()</span><br><span class="line">    let container &#x3D; oldDOM.parentNode</span><br><span class="line">    &#x2F;&#x2F; 比对</span><br><span class="line">    diff(virtualDOM, container, oldDOM)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-setState-方法实现类组件更新-二"><a href="#19-setState-方法实现类组件更新-二" class="headerlink" title="19.setState 方法实现类组件更新(二)"></a>19.setState 方法实现类组件更新(二)</h3><p>略</p>
<h3 id="20-组件更新之不是同一个组件的情况"><a href="#20-组件更新之不是同一个组件的情况" class="headerlink" title="20.组件更新之不是同一个组件的情况"></a>20.组件更新之不是同一个组件的情况</h3><p>在 diff 方法中判断要更新的 Virtual DOM 是否是组件。</p>
<p>如果是组件再判断要更新的组件和未更新前的组件是否是同一个组件，如果不是同一个组件就不需要做组件更新操作，直接调用 mountElement 方法将组件返回的 Virtual DOM 添加到页面中。</p>
<p>如果是同一个组件，就执行更新组件操作，其实就是将最新的 props 传递到组件中，再调用组件的render方法获取组件返回的最新的 Virtual DOM 对象，再将 Virtual DOM 对象传递给 diff 方法，让 diff 方法找出差异，从而将差异更新到真实 DOM 对象中。</p>
<p>在更新组件的过程中还要在不同阶段调用其不同的组件生命周期函数。</p>
<p>在 diff 方法中判断要更新的 Virtual DOM 是否是组件，如果是组件又分为多种情况，新增 diffComponent 方法进行处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">else if (typeof virtualDOM.type &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;</span><br><span class="line">  &#x2F;&#x2F; 要更新的是组件</span><br><span class="line">  &#x2F;&#x2F; 1) 组件本身的 virtualDOM 对象 通过它可以获取到组件最新的 props</span><br><span class="line">  &#x2F;&#x2F; 2) 要更新的组件的实例对象 通过它可以调用组件的生命周期函数 可以更新组件的 props 属性 可以获取到组件返回的最新的 Virtual DOM</span><br><span class="line">  &#x2F;&#x2F; 3) 要更新的 DOM 象 在更新组件时 需要在已有DOM对象的身上进行修改 实现DOM最小化操作 获取旧的 Virtual DOM 对象</span><br><span class="line">  &#x2F;&#x2F; 4) 如果要更新的组件和旧组件不是同一个组件 要直接将组件返回的 Virtual DOM 显示在页面中 此时需要 container 做为父级容器</span><br><span class="line">  diffComponent(virtualDOM, oldComponent, oldDOM, container)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 diffComponent 方法中判断要更新的组件是未更新前的组件是否是同一个组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; diffComponent.js</span><br><span class="line">export default function diffComponent(virtualDOM, oldComponent, oldDOM, container) &#123;</span><br><span class="line">  &#x2F;&#x2F; 判断要更新的组件和未更新的组件是否是同一个组件 只需要确定两者使用的是否是同一个构造函数就可以了</span><br><span class="line">  if (isSameComponent(virtualDOM, oldComponent)) &#123;</span><br><span class="line">    &#x2F;&#x2F; 属同一个组件 做组件更新  </span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 不是同一个组件 直接将组件内容显示在页面中</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; virtualDOM.type 更新后的组件构造函数</span><br><span class="line">&#x2F;&#x2F; oldComponent.constructor 未更新前的组件构造函数</span><br><span class="line">&#x2F;&#x2F; 两者等价就表示是同一组件</span><br><span class="line">function isSameComponent(virtualDOM, oldComponent) &#123;</span><br><span class="line">  return oldComponent &amp;&amp; virtualDOM.type &#x3D;&#x3D;&#x3D; oldComponent.constructor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不是同一个组件的话，就不需要执行更新组件的操作，直接将组件内容显示在页面中，替换原有内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; diffComponent.js</span><br><span class="line">else &#123;</span><br><span class="line">  &#x2F;&#x2F; 不是同一个组件 直接将组件内容显示在页面中</span><br><span class="line">  &#x2F;&#x2F; 这里为 mountElement 方法新增了一个参数 oldDOM </span><br><span class="line">  &#x2F;&#x2F; 作用是在将 DOM 对象插入到页面前 将页面中已存在的 DOM 对象删除 否则无论是旧DOM对象还是新DOM对象都会显示在页面中</span><br><span class="line">  mountElement(virtualDOM, container, oldDOM)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 mountNativeElement 方法中删除原有的旧 DOM 对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mountNavtiveElement.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">mountNativeElement</span>(<span class="params">virtualDOM, container, oldDOM</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 如果旧的DOM对象存在 删除</span></span><br><span class="line">  <span class="keyword">if</span> (oldDOM) &#123;</span><br><span class="line">    unmount(oldDOM)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; unmount.js</span><br><span class="line">export default function unmount(node) &#123;</span><br><span class="line">  node.remove()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是同一个组件的话，需要执行组件更新操作，需要调用组件生命周期函数</p>
<p>先在 Component 类中添加生命周期函数，子类要使用的话直接覆盖就可以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Component.js</span><br><span class="line">export default class Component &#123;</span><br><span class="line">  &#x2F;&#x2F; 生命周期函数</span><br><span class="line">  componentWillMount() &#123;&#125;</span><br><span class="line">  componentDidMount() &#123;&#125;</span><br><span class="line">  componentWillReceiveProps(nextProps) &#123;&#125;</span><br><span class="line">  shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">    return nextProps !&#x3D; this.props || nextState !&#x3D; this.state</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillUpdate(nextProps, nextState) &#123;&#125;</span><br><span class="line">  componentDidUpdate(prevProps, preState) &#123;&#125;</span><br><span class="line">  componentWillUnmount() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建 updateComponent 方法用于更新组件操作，并在 if 成立后调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; diffComponent.js</span><br><span class="line">if (isSameComponent(virtualDOM, oldComponent)) &#123;</span><br><span class="line">  &#x2F;&#x2F; 属同一个组件 做组件更新</span><br><span class="line">  updateComponent(virtualDOM, oldComponent, oldDOM, container)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 updateComponent 方法中调用组件的生命周期函数，更新组件获取最新 Virtual DOM，最终调用 diff 方法进行更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import diff from &quot;.&#x2F;diff&quot;</span><br><span class="line"></span><br><span class="line">export default function updateComponent(</span><br><span class="line">  virtualDOM,</span><br><span class="line">  oldComponent,</span><br><span class="line">  oldDOM,</span><br><span class="line">  container</span><br><span class="line">) &#123;</span><br><span class="line">  &#x2F;&#x2F; 生命周期函数</span><br><span class="line">  oldComponent.componentWillReceiveProps(virtualDOM.props)</span><br><span class="line">  if (</span><br><span class="line">    &#x2F;&#x2F; 调用 shouldComponentUpdate 生命周期函数判断是否要执行更新操作</span><br><span class="line">    oldComponent.shouldComponentUpdate(virtualDOM.props)</span><br><span class="line">  ) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将未更新的 props 保存一份</span><br><span class="line">    let prevProps &#x3D; oldComponent.props</span><br><span class="line">    &#x2F;&#x2F; 生命周期函数</span><br><span class="line">    oldComponent.componentWillUpdate(virtualDOM.props)</span><br><span class="line">    &#x2F;&#x2F; 更新组件的 props 属性 updateProps 方法定义在 Component 类型</span><br><span class="line">    oldComponent.updateProps(virtualDOM.props)</span><br><span class="line">    &#x2F;&#x2F; 因为组件的 props 已经更新 所以调用 render 方法获取最新的 Virtual DOM</span><br><span class="line">    const nextVirtualDOM &#x3D; oldComponent.render()</span><br><span class="line">    &#x2F;&#x2F; 将组件实例对象挂载到 Virtual DOM 身上</span><br><span class="line">    nextVirtualDOM.component &#x3D; oldComponent</span><br><span class="line">    &#x2F;&#x2F; 调用diff方法更新视图</span><br><span class="line">    diff(nextVirtualDOM, container, oldDOM)</span><br><span class="line">    &#x2F;&#x2F; 生命周期函数</span><br><span class="line">    oldComponent.componentDidUpdate(prevProps)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Component.js</span><br><span class="line">export default class Component &#123;</span><br><span class="line">  updateProps(props) &#123;</span><br><span class="line">    this.props &#x3D; props</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="21-组件更新之更新组件和旧组件是同一个组件的情况"><a href="#21-组件更新之更新组件和旧组件是同一个组件的情况" class="headerlink" title="21.组件更新之更新组件和旧组件是同一个组件的情况"></a>21.组件更新之更新组件和旧组件是同一个组件的情况</h3><p>略</p>
<h3 id="22-实现-ref-属性获取元素-DOM-对象获取组件实例对象"><a href="#22-实现-ref-属性获取元素-DOM-对象获取组件实例对象" class="headerlink" title="22.实现 ref 属性获取元素 DOM 对象获取组件实例对象"></a>22.实现 ref 属性获取元素 DOM 对象获取组件实例对象</h3><p>为节点添加 ref 属性可以获取到这个节点的 DOM 对象，比如在 DemoRef 类中，为 input 元素添加了 ref 属性，目的是获取 input DOM 元素对象，在点击按钮时获取用户在文本框中输入的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class DemoRef extends TinyReact.Component &#123;</span><br><span class="line">  handle() &#123;</span><br><span class="line">    let value &#x3D; this.input.value</span><br><span class="line">    console.log(value)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; ref&#x3D;&#123;input &#x3D;&gt; (this.input &#x3D; input)&#125; &#x2F;&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.handle.bind(this)&#125;&gt;按钮&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现思路是在创建节点时判断其 Virtual DOM 对象中是否有 ref 属性，如果有就调用 ref 属性中所存储的方法并且将创建出来的DOM对象作为参数传递给 ref 方法，这样在渲染组件节点的时候就可以拿到元素对象并将元素对象存储为组件属性了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; createDOMElement.js</span><br><span class="line">if (virtualDOM.props &amp;&amp; virtualDOM.props.ref) &#123;</span><br><span class="line">  virtualDOM.props.ref(newElement)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在类组件的身上也可以添加 ref 属性，目的是获取组件的实例对象，比如下列代码中，在 DemoRef 组件中渲染了 Alert 组件，在 Alert 组件中添加了 ref 属性，目的是在 DemoRef 组件中获取 Alert 组件实例对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class DemoRef extends TinyReact.Component &#123;</span><br><span class="line">  handle() &#123;</span><br><span class="line">    let value &#x3D; this.input.value</span><br><span class="line">    console.log(value)</span><br><span class="line">    console.log(this.alert)</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    console.log(&quot;componentDidMount&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;text&quot; ref&#x3D;&#123;input &#x3D;&gt; (this.input &#x3D; input)&#125; &#x2F;&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.handle.bind(this)&#125;&gt;按钮&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;Alert ref&#x3D;&#123;alert &#x3D;&gt; (this.alert &#x3D; alert)&#125; &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现思路是在 mountComponent 方法中，如果判断了当前处理的是类组件，就通过类组件返回的 Virtual DOM 对象中获取组件实例对象，判断组件实例对象中的 props 属性中是否存在 ref 属性，如果存在就调用 ref 方法并且将组件实例对象传递给 ref 方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; mountComponent.js</span><br><span class="line">let component &#x3D; null</span><br><span class="line">  if (isFunctionalComponent(virtualDOM)) &#123;&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">    &#x2F;&#x2F; 类组件</span><br><span class="line">    nextVirtualDOM &#x3D; buildStatefulComponent(virtualDOM)</span><br><span class="line">    &#x2F;&#x2F; 获取组件实例对象</span><br><span class="line">    component &#x3D; nextVirtualDOM.component</span><br><span class="line">  &#125;</span><br><span class="line">	&#x2F;&#x2F; 如果组件实例对象存在的话</span><br><span class="line">	if (component) &#123;</span><br><span class="line">   	&#x2F;&#x2F; 判断组件实例对象身上是否有 props 属性 props 属性中是否有 ref 属性</span><br><span class="line">    if (component.props &amp;&amp; component.props.ref) &#123;</span><br><span class="line">      &#x2F;&#x2F; 调用 ref 方法并传递组件实例对象</span><br><span class="line">      component.props.ref(component)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>代码走到这，顺便处理一下组件挂载完成的生命周期函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果组件实例对象存在的话</span><br><span class="line">if (component) &#123;</span><br><span class="line">  component.componentDidMount()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23-使用-key-属性进行节点对比-一"><a href="#23-使用-key-属性进行节点对比-一" class="headerlink" title="23.使用 key 属性进行节点对比(一)"></a>23.使用 key 属性进行节点对比(一)</h3><p>在 React 中，渲染列表数据时通常会在被渲染的列表元素上添加 key 属性，key 属性就是数据的唯一标识，帮助 React 识别哪些数据被修改或者删除了，从而达到 DOM 最小化操作的目的。</p>
<p>key 属性不需要全局唯一，但是在同一个父节点下的兄弟节点之间必须是唯一的。</p>
<p>也就是说，在比对同一个父节点下类型相同的子节点时需要用到 key 属性。</p>
<h3 id="24-使用-key-属性进行节点对比-二"><a href="#24-使用-key-属性进行节点对比-二" class="headerlink" title="24.使用 key 属性进行节点对比(二)"></a>24.使用 key 属性进行节点对比(二)</h3><p>略</p>
<h3 id="25-删除节点-一"><a href="#25-删除节点-一" class="headerlink" title="25.删除节点(一)"></a>25.删除节点(一)</h3><p>实现思路是在两个元素进行比对时，如果类型相同，就循环旧的 DOM 对象的子元素，查看其身上是否有key 属性，如果有就将这个子元素的 DOM 对象存储在一个 JavaScript 对象中，接着循环要渲染的 Virtual DOM 对象的子元素，在循环过程中获取到这个子元素的 key 属性，然后使用这个 key 属性到 JavaScript 对象中查找 DOM 对象，如果能够找到就说明这个元素是已经存在的，是不需要重新渲染的。如果通过key属性找不到这个元素，就说明这个元素是新增的是需要渲染的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; diff.js</span><br><span class="line">else if (oldVirtualDOM &amp;&amp; virtualDOM.type &#x3D;&#x3D;&#x3D; oldVirtualDOM.type) &#123;</span><br><span class="line">  &#x2F;&#x2F; 将拥有key属性的元素放入 keyedElements 对象中</span><br><span class="line">  let keyedElements &#x3D; &#123;&#125;</span><br><span class="line">  for (let i &#x3D; 0, len &#x3D; oldDOM.childNodes.length; i &lt; len; i++) &#123;</span><br><span class="line">    let domElement &#x3D; oldDOM.childNodes[i]</span><br><span class="line">    if (domElement.nodeType &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">      let key &#x3D; domElement.getAttribute(&quot;key&quot;)</span><br><span class="line">      if (key) &#123;</span><br><span class="line">        keyedElements[key] &#x3D; domElement</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; diff.js</span><br><span class="line">&#x2F;&#x2F; 看一看是否有找到了拥有 key 属性的元素</span><br><span class="line">let hasNoKey &#x3D; Object.keys(keyedElements).length &#x3D;&#x3D;&#x3D; 0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果没有找到拥有 key 属性的元素 就按照索引进行比较</span><br><span class="line">if (hasNoKey) &#123;</span><br><span class="line">  &#x2F;&#x2F; 递归对比 Virtual DOM 的子元素</span><br><span class="line">  virtualDOM.children.forEach((child, i) &#x3D;&gt; &#123;</span><br><span class="line">    diff(child, oldDOM, oldDOM.childNodes[i])</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; 使用key属性进行元素比较</span><br><span class="line">  virtualDOM.children.forEach((child, i) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取要进行比对的元素的 key 属性</span><br><span class="line">    let key &#x3D; child.props.key</span><br><span class="line">    &#x2F;&#x2F; 如果 key 属性存在</span><br><span class="line">    if (key) &#123;</span><br><span class="line">      &#x2F;&#x2F; 到已存在的 DOM 元素对象中查找对应的 DOM 元素</span><br><span class="line">      let domElement &#x3D; keyedElements[key]</span><br><span class="line">      &#x2F;&#x2F; 如果找到元素就说明该元素已经存在 不需要重新渲染</span><br><span class="line">      if (domElement) &#123;</span><br><span class="line">        &#x2F;&#x2F; 虽然 DOM 元素不需要重新渲染 但是不能确定元素的位置就一定没有发生变化</span><br><span class="line">        &#x2F;&#x2F; 所以还要查看一下元素的位置</span><br><span class="line">        &#x2F;&#x2F; 看一下 oldDOM 对应的(i)子元素和 domElement 是否是同一个元素 如果不是就说明元素位置发生了变化</span><br><span class="line">        if (oldDOM.childNodes[i] &amp;&amp; oldDOM.childNodes[i] !&#x3D;&#x3D; domElement) &#123;</span><br><span class="line">          &#x2F;&#x2F; 元素位置发生了变化</span><br><span class="line">          &#x2F;&#x2F; 将 domElement 插入到当前元素位置的前面 oldDOM.childNodes[i] 就是当前位置</span><br><span class="line">          &#x2F;&#x2F; domElement 就被放入了当前位置</span><br><span class="line">          oldDOM.insertBefore(domElement, oldDOM.childNodes[i])</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        mountElement(child, oldDOM, oldDOM.childNodes[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; mountNativeElement.js</span><br><span class="line">if (oldDOM) &#123;</span><br><span class="line">  container.insertBefore(newElement, oldDOM)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; 将转换之后的DOM对象放置在页面中</span><br><span class="line">  container.appendChild(newElement)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="26-删除节点-二"><a href="#26-删除节点-二" class="headerlink" title="26.删除节点(二)"></a>26.删除节点(二)</h3><p>在比对节点的过程中，如果旧节点的数量多于要渲染的新节点的数量就说明有节点被删除了，继续判断 keyedElements 对象中是否有元素，如果没有就使用索引方式删除，如果有就要使用 key 属性比对的方式进行删除。</p>
<p>实现思路是循环旧节点，在循环旧节点的过程中获取旧节点对应的 key 属性，然后根据 key 属性在新节点中查找这个旧节点，如果找到就说明这个节点没有被删除，如果没有找到，就说明节点被删除了，调用卸载节点的方法卸载节点即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取就节点的数量</span><br><span class="line">let oldChildNodes &#x3D; oldDOM.childNodes</span><br><span class="line">&#x2F;&#x2F; 如果旧节点的数量多于要渲染的新节点的长度</span><br><span class="line">if (oldChildNodes.length &gt; virtualDOM.children.length) &#123;</span><br><span class="line">  if (hasNoKey) &#123;</span><br><span class="line">    for (</span><br><span class="line">      let i &#x3D; oldChildNodes.length - 1;</span><br><span class="line">      i &gt;&#x3D; virtualDOM.children.length;</span><br><span class="line">      i--</span><br><span class="line">    ) &#123;</span><br><span class="line">      oldDOM.removeChild(oldChildNodes[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    for (let i &#x3D; 0; i &lt; oldChildNodes.length; i++) &#123;</span><br><span class="line">      let oldChild &#x3D; oldChildNodes[i]</span><br><span class="line">      let oldChildKey &#x3D; oldChild._virtualDOM.props.key</span><br><span class="line">      let found &#x3D; false</span><br><span class="line">      for (let n &#x3D; 0; n &lt; virtualDOM.children.length; n++) &#123;</span><br><span class="line">        if (oldChildKey &#x3D;&#x3D;&#x3D; virtualDOM.children[n].props.key) &#123;</span><br><span class="line">          found &#x3D; true</span><br><span class="line">          break</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (!found) &#123;</span><br><span class="line">        unmount(oldChild)</span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>卸载节点并不是说将节点直接删除就可以了，还需要考虑以下几种情况</p>
<ol>
<li>如果要删除的节点是文本节点的话可以直接删除</li>
<li>如果要删除的节点由组件生成，需要调用组件卸载生命周期函数</li>
<li>如果要删除的节点中包含了其他组件生成的节点，需要调用其他组件的卸载生命周期函数</li>
<li>如果要删除的节点身上有 ref 属性，还需要删除通过 ref 属性传递给组件的 DOM 节点对象</li>
<li>如果要删除的节点身上有事件，需要删除事件对应的事件处理函数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">export default function unmount(dom) &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取节点对应的 virtualDOM 对象</span><br><span class="line">  const virtualDOM &#x3D; dom._virtualDOM</span><br><span class="line">  &#x2F;&#x2F; 如果要删除的节点时文本</span><br><span class="line">  if (virtualDOM.type &#x3D;&#x3D;&#x3D; &quot;text&quot;) &#123;</span><br><span class="line">    &#x2F;&#x2F; 直接删除节点</span><br><span class="line">    dom.remove()</span><br><span class="line">    &#x2F;&#x2F; 阻止程序向下运行</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 查看节点是否由组件生成</span><br><span class="line">  let component &#x3D; virtualDOM.component</span><br><span class="line">  &#x2F;&#x2F; 如果由组件生成</span><br><span class="line">  if (component) &#123;</span><br><span class="line">    &#x2F;&#x2F; 调用组件卸载生命周期函数</span><br><span class="line">    component.componentWillUnmount()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 如果节点具有 ref 属性 通过再次调用 ref 方法 将传递给组件的DOM对象删除</span><br><span class="line">  if (virtualDOM.props &amp;&amp; virtualDOM.props.ref) &#123;</span><br><span class="line">    virtualDOM.props.ref(null)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 事件处理</span><br><span class="line">  Object.keys(virtualDOM.props).forEach(propName &#x3D;&gt; &#123;</span><br><span class="line">    if (propName.slice(0, 2) &#x3D;&#x3D;&#x3D; &quot;on&quot;) &#123;</span><br><span class="line">      const eventName &#x3D; propName.toLowerCase().slice(2)</span><br><span class="line">      const eventHandler &#x3D; virtualDOM.props[propName]</span><br><span class="line">      dom.removeEventListener(eventName, eventHandler)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">	</span><br><span class="line">  &#x2F;&#x2F; 递归删除子节点</span><br><span class="line">  if (dom.childNodes.length &gt; 0) &#123;</span><br><span class="line">    for (let i &#x3D; 0; i &lt; dom.childNodes.length; i++) &#123;</span><br><span class="line">      unmount(dom.childNodes[i])</span><br><span class="line">      i--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  	</span><br><span class="line">  dom.remove()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="任务三：Fiber"><a href="#任务三：Fiber" class="headerlink" title="任务三：Fiber"></a>任务三：Fiber</h2><h3 id="1-开发环境配置-一"><a href="#1-开发环境配置-一" class="headerlink" title="1.开发环境配置(一)"></a>1.开发环境配置(一)</h3><blockquote>
<p>文件夹结构</p>
</blockquote>
<table>
<thead>
<tr>
<th>文件 / 文件夹</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>src</td>
<td>存储源文件</td>
</tr>
<tr>
<td>dist</td>
<td>存储客户端代码打包文件</td>
</tr>
<tr>
<td>build</td>
<td>存储服务端代码打包文件</td>
</tr>
<tr>
<td>server.js</td>
<td>存储服务器端代码</td>
</tr>
<tr>
<td>webpack.config.server.js</td>
<td>服务端 webpack 配置文件</td>
</tr>
<tr>
<td>webpack.config.client.js</td>
<td>客户端 webpack 配置文件</td>
</tr>
<tr>
<td>babel.config.json</td>
<td>babel 配置文件</td>
</tr>
<tr>
<td>package.json</td>
<td>项目工程文件</td>
</tr>
</tbody></table>
<p>创建 package.json 文件：<code>npm init -y</code></p>
<blockquote>
<p>安装项目依赖</p>
</blockquote>
<p>开发依赖：<code>npm install webpack webpack-cli webpack-node-externals @babel/core @babel/preset-env @babel/preset-react babel-loader nodemon npm-run-all -D</code></p>
<p>项目依赖：<code>npm install express</code></p>
<table>
<thead>
<tr>
<th>依赖项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>webpack</td>
<td>模块打包工具</td>
</tr>
<tr>
<td>webpack-cli</td>
<td>打包命令</td>
</tr>
<tr>
<td>webpack-node-externals</td>
<td>打包服务器端模块时剔除 node_modules 文件夹中的模块</td>
</tr>
<tr>
<td>@babel/core</td>
<td>JavaScript 代码转换工具</td>
</tr>
<tr>
<td>@babel/preset-env</td>
<td>babel 预置，转换高级 JavaScript 语法</td>
</tr>
<tr>
<td>@babel/preset-react</td>
<td>babel 预置，转换 JSX 语法</td>
</tr>
<tr>
<td>babel-loader</td>
<td>webpack 中的 babel 工具加载器</td>
</tr>
<tr>
<td>nodemon</td>
<td>监控服务端文件变化，重启应用</td>
</tr>
<tr>
<td>npm-run-all</td>
<td>命令行工具，可以同时执行多个命令</td>
</tr>
<tr>
<td>express</td>
<td>基于 node 平台的 web 开发框架</td>
</tr>
</tbody></table>
<h3 id="2-开发环境配置-二"><a href="#2-开发环境配置-二" class="headerlink" title="2.开发环境配置(二)"></a>2.开发环境配置(二)</h3><blockquote>
<p>创建 web 服务器</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"><span class="keyword">import</span> express <span class="keyword">from</span> <span class="string">"express"</span></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line">app.use(express.static(<span class="string">"dist"</span>))</span><br><span class="line"><span class="keyword">const</span> template = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;html&gt;</span></span><br><span class="line"><span class="string">    &lt;head&gt;</span></span><br><span class="line"><span class="string">      &lt;title&gt;React Fiber&lt;/title&gt;</span></span><br><span class="line"><span class="string">    &lt;/head&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">      &lt;div id="root"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">			&lt;script src="bundle.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">  &lt;/html&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">app.get(<span class="string">"*"</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(template)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">"server is running"</span>))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>服务端 webpack 配置</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.server.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>)</span><br><span class="line"><span class="keyword">const</span> nodeExternals = <span class="built_in">require</span>(<span class="string">"webpack-node-externals"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  target: <span class="string">"node"</span>,</span><br><span class="line">  mode: <span class="string">"development"</span>,</span><br><span class="line">  entry: <span class="string">"./server.js"</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"server.js"</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"build"</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">"babel-loader"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  externals: [nodeExternals()]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>babel 配置</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"presets"</span>: [<span class="string">"@babel/preset-env"</span>, <span class="string">"@babel/preset-react"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-开发环境配置-三"><a href="#3-开发环境配置-三" class="headerlink" title="3.开发环境配置(三)"></a>3.开发环境配置(三)</h3><blockquote>
<p>客户端 webpack 配置</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  target: <span class="string">"web"</span>,</span><br><span class="line">  mode: <span class="string">"development"</span>,</span><br><span class="line">  entry: <span class="string">"./src/index.js"</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"bundle.js"</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">"dist"</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">"source-map"</span>,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">"babel-loader"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>启动命令</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "start": "npm-run-all --parallel dev:*",</span><br><span class="line">  "dev:server-compile": "webpack --config webpack.config.server.js --watch",</span><br><span class="line">  "dev:server": "nodemon ./build/server.js",</span><br><span class="line">  "dev:client-compile": "webpack --config webpack.config.client.js --watch"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="4-requestIdleCallback-API-介绍及浏览器空余时间说明"><a href="#4-requestIdleCallback-API-介绍及浏览器空余时间说明" class="headerlink" title="4.requestIdleCallback API 介绍及浏览器空余时间说明"></a>4.requestIdleCallback API 介绍及浏览器空余时间说明</h3><blockquote>
<p>核心 API 功能介绍</p>
</blockquote>
<p>利用浏览器的空余时间执行任务，如果有更高优先级的任务要执行时，当前执行的任务可以被终止，优先执行高级别任务。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">requestIdleCallback(<span class="function"><span class="keyword">function</span>(<span class="params">deadline</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// deadline.timeRemaining() 获取浏览器的空余时间</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>浏览器空余时间</p>
</blockquote>
<p>页面是一帧一帧绘制出来的，当每秒绘制的帧数达到 60 时，页面是流畅的，小于这个值时， 用户会感觉到卡顿</p>
<p>1s 60帧，每一帧分到的时间是 1000/60 ≈ 16 ms，如果每一帧执行的时间小于16ms，就说明浏览器有空余时间</p>
<p>如果任务在剩余的时间内没有完成则会停止任务执行，继续优先执行主任务，也就是说 requestIdleCallback 总是利用浏览器的空余时间执行任务</p>
<h3 id="5-requestIdleCallback使用方法"><a href="#5-requestIdleCallback使用方法" class="headerlink" title="5.requestIdleCallback使用方法"></a>5.requestIdleCallback使用方法</h3><p>页面中有两个按钮和一个DIV，点击第一个按钮执行一项昂贵的计算，使其长期占用主线程，当计算任务执行的时候去点击第二个按钮更改页面中 DIV 的背景颜色。</p>
<p>使用 requestIdleCallback 就可以完美解决这个卡顿问题。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"playground"</span> <span class="attr">id</span>=<span class="string">"play"</span>&gt;</span>playground<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"work"</span>&gt;</span>start work<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"interaction"</span>&gt;</span>handle some user interaction<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">  <span class="selector-class">.playground</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: palevioletred;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> play = <span class="built_in">document</span>.getElementById(<span class="string">"play"</span>)</span><br><span class="line"><span class="keyword">var</span> workBtn = <span class="built_in">document</span>.getElementById(<span class="string">"work"</span>)</span><br><span class="line"><span class="keyword">var</span> interactionBtn = <span class="built_in">document</span>.getElementById(<span class="string">"interaction"</span>)</span><br><span class="line"><span class="keyword">var</span> iterationCount = <span class="number">100000000</span></span><br><span class="line"><span class="keyword">var</span> value = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> expensiveCalculation = <span class="function"><span class="keyword">function</span> (<span class="params">IdleDeadline</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (iterationCount &gt; <span class="number">0</span> &amp;&amp; IdleDeadline.timeRemaining() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    value =</span><br><span class="line">      <span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span> ? value + <span class="built_in">Math</span>.random() : value + <span class="built_in">Math</span>.random()</span><br><span class="line">    iterationCount = iterationCount - <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  requestIdleCallback(expensiveCalculation)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">workBtn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  requestIdleCallback(expensiveCalculation)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">interactionBtn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  play.style.background = <span class="string">"palegreen"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="6-旧版Stack算法存在的问题以及新版Fiber解决方案介绍"><a href="#6-旧版Stack算法存在的问题以及新版Fiber解决方案介绍" class="headerlink" title="6.旧版Stack算法存在的问题以及新版Fiber解决方案介绍"></a>6.旧版Stack算法存在的问题以及新版Fiber解决方案介绍</h3><blockquote>
<p>问题</p>
</blockquote>
<p>React 16 之前的版本比对更新 VirtualDOM 的过程是采用循环加递归实现的，这种比对方式有一个问题，就是一旦任务开始进行就无法中断，如果应用中组件数量庞大，主线程被长期占用，直到整棵 VirtualDOM 树比对更新完成之后主线程才能被释放，主线程才能执行其他任务。这就会导致一些用户交互，动画等任务无法立即得到执行，页面就会产生卡顿, 非常的影响用户体验。 </p>
<p>核心问题：递归无法中断，执行重任务耗时长。 JavaScript 又是单线程，无法同时执行其他任务，导致任务延迟页面卡顿，用户体验差。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<ol>
<li>利用浏览器空闲时间执行任务，拒绝长时间占用主线程</li>
<li>放弃递归只采用循环，因为循环可以被中断</li>
<li>任务拆分，将任务拆分成一个个的小任务</li>
</ol>
<h3 id="7-fiber算法实现思路以及fiber对象结构预览"><a href="#7-fiber算法实现思路以及fiber对象结构预览" class="headerlink" title="7.fiber算法实现思路以及fiber对象结构预览"></a>7.fiber算法实现思路以及fiber对象结构预览</h3><blockquote>
<p>实现思路</p>
</blockquote>
<p>在 Fiber 方案中，为了实现任务的终止再继续，DOM比对算法被分成了两部分：</p>
<ol>
<li>构建 Fiber        (可中断)</li>
<li>提交 Commit   (不可中断)</li>
</ol>
<p>DOM 初始渲染: virtualDOM -&gt; Fiber -&gt; Fiber[] -&gt; DOM</p>
<p>DOM 更新操作: newFiber vs oldFiber -&gt; Fiber[] -&gt; DOM</p>
<blockquote>
<p>Fiber 对象</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type         节点类型 (元素, 文本, 组件)(具体的类型)</span><br><span class="line">  props        节点属性</span><br><span class="line">  stateNode    节点 DOM 对象 | 组件实例对象</span><br><span class="line">  tag          节点标记 (对具体类型的分类 hostRoot || hostComponent || classComponent || functionComponent)</span><br><span class="line">  effects      数组, 存储需要更改的 fiber 对象</span><br><span class="line">  effectTag    当前 Fiber 要被执行的操作 (新增, 删除, 修改)</span><br><span class="line">  parent       当前 Fiber 的父级 Fiber</span><br><span class="line">  child        当前 Fiber 的子级 Fiber</span><br><span class="line">  sibling      当前 Fiber 的下一个兄弟 Fiber</span><br><span class="line">  alternate    Fiber 备份 fiber 比对时使用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-创建任务队列并添加任务"><a href="#8-创建任务队列并添加任务" class="headerlink" title="8.创建任务队列并添加任务"></a>8.创建任务队列并添加任务</h3><h3 id="9-实现任务的调度逻辑"><a href="#9-实现任务的调度逻辑" class="headerlink" title="9.实现任务的调度逻辑"></a>9.实现任务的调度逻辑</h3><h3 id="10-构建根节点Fiber对象"><a href="#10-构建根节点Fiber对象" class="headerlink" title="10.构建根节点Fiber对象"></a>10.构建根节点Fiber对象</h3><h3 id="11-构建子级节点Fiber对象"><a href="#11-构建子级节点Fiber对象" class="headerlink" title="11.构建子级节点Fiber对象"></a>11.构建子级节点Fiber对象</h3><h3 id="12-完善fiber对象-stateNode属性"><a href="#12-完善fiber对象-stateNode属性" class="headerlink" title="12.完善fiber对象-stateNode属性"></a>12.完善fiber对象-stateNode属性</h3><h3 id="13-完善fiber对象-tag属性"><a href="#13-完善fiber对象-tag属性" class="headerlink" title="13.完善fiber对象-tag属性"></a>13.完善fiber对象-tag属性</h3><h3 id="14-构建左侧节点树中的剩余子级节点Fiber对象"><a href="#14-构建左侧节点树中的剩余子级节点Fiber对象" class="headerlink" title="14.构建左侧节点树中的剩余子级节点Fiber对象"></a>14.构建左侧节点树中的剩余子级节点Fiber对象</h3><h3 id="15-构建剩余节点的fiber对象"><a href="#15-构建剩余节点的fiber对象" class="headerlink" title="15.构建剩余节点的fiber对象"></a>15.构建剩余节点的fiber对象</h3><h3 id="16-构建effects数组"><a href="#16-构建effects数组" class="headerlink" title="16.构建effects数组"></a>16.构建effects数组</h3><h3 id="17-fiber第二阶段-实现初始渲染"><a href="#17-fiber第二阶段-实现初始渲染" class="headerlink" title="17.fiber第二阶段-实现初始渲染"></a>17.fiber第二阶段-实现初始渲染</h3><h3 id="18-类组件处理"><a href="#18-类组件处理" class="headerlink" title="18.类组件处理"></a>18.类组件处理</h3><h3 id="19-处理函数组件"><a href="#19-处理函数组件" class="headerlink" title="19.处理函数组件"></a>19.处理函数组件</h3><h3 id="20-实现更新节点"><a href="#20-实现更新节点" class="headerlink" title="20.实现更新节点"></a>20.实现更新节点</h3><h3 id="21-扩展更新节点的方法"><a href="#21-扩展更新节点的方法" class="headerlink" title="21.扩展更新节点的方法"></a>21.扩展更新节点的方法</h3><h3 id="22-实现节点删除操作"><a href="#22-实现节点删除操作" class="headerlink" title="22.实现节点删除操作"></a>22.实现节点删除操作</h3><h3 id="23-实现类组件状态更新功能"><a href="#23-实现类组件状态更新功能" class="headerlink" title="23.实现类组件状态更新功能"></a>23.实现类组件状态更新功能</h3><h2 id="任务四：React-核心源码解读"><a href="#任务四：React-核心源码解读" class="headerlink" title="任务四：React 核心源码解读"></a>任务四：React 核心源码解读</h2><h3 id="1-搭建React源码本地调试环境"><a href="#1-搭建React源码本地调试环境" class="headerlink" title="1.搭建React源码本地调试环境"></a>1.搭建React源码本地调试环境</h3><ol>
<li><p>使用 create-react-app 脚手架创建项目</p>
<p><code>npx create-react-app react-test</code></p>
</li>
<li><p>弹射 create-react-app 脚手架内部配置</p>
<p><code>npm run eject</code></p>
</li>
<li><p>克隆 react 官方源码 (在项目的根目录下进行克隆)</p>
<p><code>git clone --branch v16.13.1 --depth=1 https://github.com/facebook/react.git src/react</code></p>
</li>
<li><p>链接本地源码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件位置: react-test/config/webpack.config.js</span></span><br><span class="line">resolve: &#123;</span><br><span class="line">  alias: &#123;</span><br><span class="line">    <span class="string">"react-native"</span>: <span class="string">"react-native-web"</span>,</span><br><span class="line">    <span class="string">"react"</span>: path.resolve(__dirname, <span class="string">"../src/react/packages/react"</span>),</span><br><span class="line">    <span class="string">"react-dom"</span>: path.resolve(__dirname, <span class="string">"../src/react/packages/react-dom"</span>),</span><br><span class="line">    <span class="string">"shared"</span>: path.resolve(__dirname, <span class="string">"../src/react/packages/shared"</span>),</span><br><span class="line">    <span class="string">"react-reconciler"</span>: path.resolve(__dirname, <span class="string">"../src/react/packages/react-reconciler"</span>),</span><br><span class="line">    <span class="string">"legacy-events"</span>: path.resolve(__dirname, <span class="string">"../src/react/packages/legacy-events"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改环境变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件位置: react-test/config/env.js</span></span><br><span class="line"><span class="keyword">const</span> stringified = &#123;</span><br><span class="line">	<span class="string">"process.env"</span>: <span class="built_in">Object</span>.keys(raw).reduce(<span class="function">(<span class="params">env, key</span>) =&gt;</span> &#123;</span><br><span class="line">   	env[key] = <span class="built_in">JSON</span>.stringify(raw[key])</span><br><span class="line">      <span class="keyword">return</span> env</span><br><span class="line">   &#125;, &#123;&#125;),</span><br><span class="line">   __DEV__: <span class="literal">true</span>,</span><br><span class="line">   SharedArrayBuffer: <span class="literal">true</span>,</span><br><span class="line">   spyOnDev: <span class="literal">true</span>,</span><br><span class="line">   spyOnDevAndProd: <span class="literal">true</span>,</span><br><span class="line">   spyOnProd: <span class="literal">true</span>,</span><br><span class="line">   __PROFILE__: <span class="literal">true</span>,</span><br><span class="line">   __UMD__: <span class="literal">true</span>,</span><br><span class="line">   __EXPERIMENTAL__: <span class="literal">true</span>,</span><br><span class="line">   __VARIANT__: <span class="literal">true</span>,</span><br><span class="line">   gate: <span class="literal">true</span>,</span><br><span class="line">   trustedTypes: <span class="literal">true</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>告诉 babel 在转换代码时忽略类型检查</p>
<p><code>npm install @babel/plugin-transform-flow-strip-types -D</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件位置: react-test/config/webpack.config.js [babel-loader]</span></span><br><span class="line">plugins: [</span><br><span class="line">  <span class="built_in">require</span>.resolve(<span class="string">"@babel/plugin-transform-flow-strip-types"</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>导出 HostConfig</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件位置: /react/packages/react-reconciler/src/ReactFiberHostConfig.js</span></span><br><span class="line">+ <span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./forks/ReactFiberHostConfig.dom'</span>;</span><br><span class="line">- invariant(<span class="literal">false</span>, <span class="string">'This module must be shimmed by a specific renderer.'</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 ReactSharedInternals.js 文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件位置: /react/packages/shared/ReactSharedInternals.js</span></span><br><span class="line">- <span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line">- <span class="keyword">const</span> ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;</span><br><span class="line">+ <span class="keyword">import</span> ReactSharedInternals <span class="keyword">from</span> <span class="string">'../react/src/ReactSharedInternals'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭 eslint 扩展</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件位置: react/.eslingrc.js [module.exports]</span></span><br><span class="line"><span class="comment">// 删除 extends</span></span><br><span class="line">extends: [</span><br><span class="line">  <span class="string">'fbjs'</span>,</span><br><span class="line">  <span class="string">'prettier'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>禁止 invariant 报错</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件位置: /react/packages/shared/invariant.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">invariant</span>(<span class="params">condition, format, a, b, c, d, e, f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (condition) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">    <span class="string">'Internal React error: invariant() is meant to be replaced at compile '</span> +</span><br><span class="line">      <span class="string">'time. There is no runtime version.'</span>,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>eslint 配置</p>
<p>在 react 源码文件夹中新建 .eslintrc.json 并添加如下配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;extends&quot;: &quot;react-app&quot;,</span><br><span class="line">  &quot;globals&quot;: &#123;</span><br><span class="line">    &quot;SharedArrayBuffer&quot;: true,</span><br><span class="line">    &quot;spyOnDev&quot;: true,</span><br><span class="line">    &quot;spyOnDevAndProd&quot;: true,</span><br><span class="line">    &quot;spyOnProd&quot;: true,</span><br><span class="line">    &quot;__PROFILE__&quot;: true,</span><br><span class="line">    &quot;__UMD__&quot;: true,</span><br><span class="line">    &quot;__EXPERIMENTAL__&quot;: true,</span><br><span class="line">    &quot;__VARIANT__&quot;: true,</span><br><span class="line">    &quot;gate&quot;: true,</span><br><span class="line">    &quot;trustedTypes&quot;: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 react react-dom 引入方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">"react"</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解决 vsCode 中 flow 报错</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"javascript.validate.enable"</span>: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可选项配置</p>
<p>如果你的 vscode 编辑器安装了 prettier 插件并且在保存 react 源码文件时右下角出现如下错误，按照如下步骤解决</p>
<ol>
<li><p>全局安装 prettier</p>
<p><code>npm i prettier -g</code></p>
</li>
<li><p>配置 prettier path</p>
<p>Settings &gt; Extensions &gt; Prettier &gt; Prettier path</p>
</li>
</ol>
</li>
</ol>
<ol start="15">
<li><p>__DEV__ 报错</p>
<p>删除 node_modules 文件夹，执行 npm install</p>
</li>
</ol>
<h3 id="2-JSX转换为ReactElement的过程"><a href="#2-JSX转换为ReactElement的过程" class="headerlink" title="2.JSX转换为ReactElement的过程"></a>2.JSX转换为ReactElement的过程</h3><p>JSX 被 Babel 编译为 React.createElement 方法的调用，createElement 方法在调用后返回的就是 ReactElement，就是 virtualDOM。</p>
<blockquote>
<p>createElement</p>
</blockquote>
<p><code>文件位置：packages/react/src/ReactElement.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 创建 React Element</span><br><span class="line"> * type      元素类型</span><br><span class="line"> * config    配置属性</span><br><span class="line"> * children  子元素</span><br><span class="line"> * 1. 分离 props 属性和特殊属性</span><br><span class="line"> * 2. 将子元素挂载到 props.children 中</span><br><span class="line"> * 3. 为 props 属性赋默认值 (defaultProps)</span><br><span class="line"> * 4. 创建并返回 ReactElement</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function createElement(type, config, children) &#123;</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * propName -&gt; 属性名称</span><br><span class="line">   * 用于后面的 for 循环</span><br><span class="line">   *&#x2F;</span><br><span class="line">  let propName;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 存储 React Element 中的普通元素属性 即不包含 key ref self source</span><br><span class="line">   *&#x2F;</span><br><span class="line">  const props &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 待提取属性</span><br><span class="line">   * React 内部为了实现某些功能而存在的属性</span><br><span class="line">   *&#x2F;</span><br><span class="line">  let key &#x3D; null;</span><br><span class="line">  let ref &#x3D; null;</span><br><span class="line">  let self &#x3D; null;</span><br><span class="line">  let source &#x3D; null;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果 config 不为 null</span><br><span class="line">  if (config !&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果 config 对象中有合法的 ref 属性</span><br><span class="line">    if (hasValidRef(config)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 将 config.ref 属性提取到 ref 变量中</span><br><span class="line">      ref &#x3D; config.ref;</span><br><span class="line">      &#x2F;&#x2F; 在开发环境中</span><br><span class="line">      if (__DEV__) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果 ref 属性的值被设置成了字符串形式就报一个提示</span><br><span class="line">        &#x2F;&#x2F; 说明此用法在将来的版本中会被删除</span><br><span class="line">        warnIfStringRefCannotBeAutoConverted(config);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果在 config 对象中拥有合法的 key 属性</span><br><span class="line">    if (hasValidKey(config)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 将 config.key 属性中的值提取到 key 变量中</span><br><span class="line">      key &#x3D; &#39;&#39; + config.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self &#x3D; config.__self &#x3D;&#x3D;&#x3D; undefined ? null : config.__self;</span><br><span class="line">    source &#x3D; config.__source &#x3D;&#x3D;&#x3D; undefined ? null : config.__source;</span><br><span class="line">    &#x2F;&#x2F; 遍历 config 对象</span><br><span class="line">    for (propName in config) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果当前遍历到的属性是对象自身属性</span><br><span class="line">      &#x2F;&#x2F; 并且在 RESERVED_PROPS 对象中不存在该属性</span><br><span class="line">      if (</span><br><span class="line">        hasOwnProperty.call(config, propName) &amp;&amp;</span><br><span class="line">        !RESERVED_PROPS.hasOwnProperty(propName)</span><br><span class="line">      ) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将满足条件的属性添加到 props 对象中 (普通属性)</span><br><span class="line">        props[propName] &#x3D; config[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 将第三个及之后的参数挂载到 props.children 属性中</span><br><span class="line">   * 如果子元素是多个 props.children 是数组</span><br><span class="line">   * 如果子元素是一个 props.children 是对象</span><br><span class="line">   *&#x2F;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 由于从第三个参数开始及以后都表示子元素</span><br><span class="line">  &#x2F;&#x2F; 所以减去前两个参数的结果就是子元素的数量</span><br><span class="line">  const childrenLength &#x3D; arguments.length - 2;</span><br><span class="line">  &#x2F;&#x2F; 如果子元素的数量是 1</span><br><span class="line">  if (childrenLength &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">    &#x2F;&#x2F; 直接将子元素挂载到到 props.children 属性上</span><br><span class="line">    &#x2F;&#x2F; 此时 children 是对象类型</span><br><span class="line">    props.children &#x3D; children;</span><br><span class="line">    &#x2F;&#x2F; 如果子元素的数量大于 1</span><br><span class="line">  &#125; else if (childrenLength &gt; 1) &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建数组, 数组中元素的数量等于子元素的数量</span><br><span class="line">    const childArray &#x3D; Array(childrenLength);</span><br><span class="line">    &#x2F;&#x2F; 开启循环 循环次匹配子元素的数量</span><br><span class="line">    for (let i &#x3D; 0; i &lt; childrenLength; i++) &#123;</span><br><span class="line">      &#x2F;&#x2F; 将子元素添加到 childArray 数组中</span><br><span class="line">      &#x2F;&#x2F; i + 2 的原因是实参集合的前两个参数不是子元素</span><br><span class="line">      childArray[i] &#x3D; arguments[i + 2];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果是开发环境</span><br><span class="line">    if (__DEV__) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果 Object 对象中存在 freeze 方法</span><br><span class="line">      if (Object.freeze) &#123;</span><br><span class="line">        &#x2F;&#x2F; 调用 freeze 方法 冻结 childArray 数组</span><br><span class="line">        &#x2F;&#x2F; 防止 React 核心对象被修改 冻结对象提高性能</span><br><span class="line">        Object.freeze(childArray);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 将子元素数组挂载到 props.children 属性中</span><br><span class="line">    props.children &#x3D; childArray;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 如果当前处理是组件</span><br><span class="line">   * 看组件身上是否有 defaultProps 属性</span><br><span class="line">   * 这个属性中存储的是 props 对象中属性的默认值</span><br><span class="line">   * 遍历 defaultProps 对象 查看对应的 props 属性的值是否为 undefined</span><br><span class="line">   * 如果为undefined 就将默认值赋值给对应的 props 属性值</span><br><span class="line">   *&#x2F;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 将 type 属性值视为函数 查看其中是否具有 defaultProps 属性</span><br><span class="line">  if (type &amp;&amp; type.defaultProps) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将 type 函数下的 defaultProps 属性赋值给 defaultProps 变量</span><br><span class="line">    const defaultProps &#x3D; type.defaultProps;</span><br><span class="line">    &#x2F;&#x2F; 遍历 defaultProps 对象中的属性 将属性名称赋值给 propName 变量</span><br><span class="line">    for (propName in defaultProps) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果 props 对象中的该属性的值为 undefined</span><br><span class="line">      if (props[propName] &#x3D;&#x3D;&#x3D; undefined) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将 defaultProps 对象中的对应属性的值赋值给 props 对象中的对应属性的值</span><br><span class="line">        props[propName] &#x3D; defaultProps[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 在开发环境中 如果元素的 key 属性 或者 ref 属性存在</span><br><span class="line">   * 监测开发者是否在组件内部通过 props 对象获取了 key 属性或者 ref 属性</span><br><span class="line">   * 如果获取了 就报错</span><br><span class="line">   *&#x2F;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果处于开发环境</span><br><span class="line">  if (__DEV__) &#123;</span><br><span class="line">    &#x2F;&#x2F; 元素具有 key 属性或者 ref 属性</span><br><span class="line">    if (key || ref) &#123;</span><br><span class="line">      &#x2F;&#x2F; 看一下 type 属性中存储的是否是函数 如果是函数就表示当前元素是组件</span><br><span class="line">      &#x2F;&#x2F; 如果元素不是组件 就直接返回元素类型字符串</span><br><span class="line">      &#x2F;&#x2F; displayName 用于在报错过程中显示是哪一个组件报错了</span><br><span class="line">      &#x2F;&#x2F; 如果开发者显式定义了 displayName 属性 就显示开发者定义的</span><br><span class="line">      &#x2F;&#x2F; 否者就显示组件名称 如果组件也没有名称 就显示 &#39;Unknown&#39;</span><br><span class="line">      const displayName &#x3D;</span><br><span class="line">        typeof type &#x3D;&#x3D;&#x3D; &#39;function&#39;</span><br><span class="line">          ? type.displayName || type.name || &#39;Unknown&#39;</span><br><span class="line">          : type;</span><br><span class="line">      &#x2F;&#x2F; 如果 key 属性存在</span><br><span class="line">      if (key) &#123;</span><br><span class="line">        &#x2F;&#x2F; 为 props 对象添加key 属性</span><br><span class="line">        &#x2F;&#x2F; 并指定当通过 props 对象获取 key 属性时报错</span><br><span class="line">        defineKeyPropWarningGetter(props, displayName);</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 如果 ref 属性存在</span><br><span class="line">      if (ref) &#123;</span><br><span class="line">        &#x2F;&#x2F; 为 props 对象添加 ref 属性</span><br><span class="line">        &#x2F;&#x2F; 并指定当通过 props 对象获取 ref 属性时报错</span><br><span class="line">        defineRefPropWarningGetter(props, displayName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 返回 ReactElement</span><br><span class="line">  return ReactElement(</span><br><span class="line">    type,</span><br><span class="line">    key,</span><br><span class="line">    ref,</span><br><span class="line">    self,</span><br><span class="line">    source,</span><br><span class="line">    &#x2F;&#x2F; 在 Virtual DOM 中用于识别自定义组件</span><br><span class="line">    ReactCurrentOwner.current,</span><br><span class="line">    props,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-React检测开发者是否错误的使用了props属性"><a href="#3-React检测开发者是否错误的使用了props属性" class="headerlink" title="3.React检测开发者是否错误的使用了props属性"></a>3.React检测开发者是否错误的使用了props属性</h3><blockquote>
<p>ReactElement</p>
</blockquote>
<p><code>文件位置：packages/react/src/ReactElement.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 接收参数 返回 ReactElement</span><br><span class="line"> *&#x2F;</span><br><span class="line">const ReactElement &#x3D; function (type, key, ref, self, source, owner, props) &#123;</span><br><span class="line">  const element &#x3D; &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 组件的类型, 十六进制数值或者 Symbol 值</span><br><span class="line">     * React 在最终在渲染 DOM 的时候, 需要确保元素的类型是 REACT_ELEMENT_TYPE</span><br><span class="line">     * 需要此属性作为判断的依据</span><br><span class="line">     *&#x2F;</span><br><span class="line">    $$typeof: REACT_ELEMENT_TYPE,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 元素具体的类型值 如果是元素节点 type 属性中存储的就是 div span 等等</span><br><span class="line">     * 如果元素是组件 type 属性中存储的就是组件的构造函数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    type: type,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 元素的唯一标识</span><br><span class="line">     * 用作内部 vdom 比对 提升 DOM 操作性能</span><br><span class="line">     *&#x2F;</span><br><span class="line">    key: key,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 存储元素 DOM 对象或者组件 实例对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    ref: ref,</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 存储向组件内部传递的数据</span><br><span class="line">     *&#x2F;</span><br><span class="line">    props: props,</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 记录当前元素所属组件 (记录当前元素是哪个组件创建的)</span><br><span class="line">     *&#x2F;</span><br><span class="line">    _owner: owner,</span><br><span class="line">  &#125;;</span><br><span class="line">  &#x2F;&#x2F; 返回 ReactElement</span><br><span class="line">  return element;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>hasValidRef</p>
</blockquote>
<p><code>文件位置：packages/react/src/ReactElement.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 查看参数对象中是否有合法的 ref 属性</span><br><span class="line"> * 返回布尔值</span><br><span class="line"> *&#x2F;</span><br><span class="line">function hasValidRef(config) &#123;</span><br><span class="line">  return config.ref !&#x3D;&#x3D; undefined;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>hasValidKey</p>
</blockquote>
<p><code>文件位置：packages/react/src/ReactElement.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 查看参数对象中是否有合法的 key 属性</span><br><span class="line"> * 返回布尔值</span><br><span class="line"> *&#x2F;</span><br><span class="line">function hasValidKey(config) &#123;</span><br><span class="line">  return config.key !&#x3D;&#x3D; undefined;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-isValidElement方法的内部实现"><a href="#4-isValidElement方法的内部实现" class="headerlink" title="4.isValidElement方法的内部实现"></a>4.isValidElement方法的内部实现</h3><blockquote>
<p>isValidElement</p>
</blockquote>
<p><code>文件位置：packages/react/src/ReactElement.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 验证 object 参数是否是 ReactElement. 返回布尔值</span><br><span class="line"> * 验证成功的条件:</span><br><span class="line"> * object 是对象</span><br><span class="line"> * object 不为null</span><br><span class="line"> * object对象中的 $$typeof 属性值为 REACT_ELEMENT_TYPE</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function isValidElement(object) &#123;</span><br><span class="line">  return (</span><br><span class="line">    typeof object &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp;</span><br><span class="line">    object !&#x3D;&#x3D; null &amp;&amp;</span><br><span class="line">    object.$$typeof &#x3D;&#x3D;&#x3D; REACT_ELEMENT_TYPE</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>defineKeyPropWarningGetter</p>
</blockquote>
<p><code>文件位置：packages/react/src/ReactElement.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  指定当通过 props 对象获取 key 属性时报错</span><br><span class="line"> *  props        组件中的 props 对象</span><br><span class="line"> *  displayName  组件名称标识</span><br><span class="line"> *&#x2F;</span><br><span class="line">function defineKeyPropWarningGetter(props, displayName) &#123;</span><br><span class="line">  &#x2F;&#x2F; 通过 props 对象获取 key 属性报错</span><br><span class="line">  const warnAboutAccessingKey &#x3D; function () &#123;</span><br><span class="line">    &#x2F;&#x2F; 在开发环境中</span><br><span class="line">    if (__DEV__) &#123;</span><br><span class="line">      &#x2F;&#x2F; specialPropKeyWarningShown 控制错误只输出一次的变量</span><br><span class="line">      if (!specialPropKeyWarningShown) &#123;</span><br><span class="line">        &#x2F;&#x2F; 通过 specialPropKeyWarningShown 变量锁住判断条件</span><br><span class="line">        specialPropKeyWarningShown &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F; 指定报错信息和组件名称</span><br><span class="line">        console.error(</span><br><span class="line">          &#39;%s: &#96;key&#96; is not a prop. Trying to access it will result &#39; +</span><br><span class="line">            &#39;in &#96;undefined&#96; being returned. If you need to access the same &#39; +</span><br><span class="line">            &#39;value within the child component, you should pass it as a different &#39; +</span><br><span class="line">            &#39;prop. (https:&#x2F;&#x2F;reactjs.org&#x2F;link&#x2F;special-props)&#39;,</span><br><span class="line">          displayName,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  warnAboutAccessingKey.isReactWarning &#x3D; true;</span><br><span class="line">  &#x2F;&#x2F; 为 props 对象添加 key 属性</span><br><span class="line">  Object.defineProperty(props, &#39;key&#39;, &#123;</span><br><span class="line">    &#x2F;&#x2F; 当获取 key 属性时调用 warnAboutAccessingKey 方法进行报错</span><br><span class="line">    get: warnAboutAccessingKey,</span><br><span class="line">    configurable: true,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>defineRefPropWarningGetter</p>
</blockquote>
<p><code>文件位置：packages/react/src/ReactElement.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *  指定当通过 props 对象获取 ref 属性时报错</span><br><span class="line"> *  props        组件中的 props 对象</span><br><span class="line"> *  displayName  组件名称标识</span><br><span class="line"> *&#x2F;</span><br><span class="line">function defineRefPropWarningGetter(props, displayName) &#123;</span><br><span class="line">  &#x2F;&#x2F; 通过 props 对象获取 ref 属性报错</span><br><span class="line">  const warnAboutAccessingRef &#x3D; function () &#123;</span><br><span class="line">    if (__DEV__) &#123;</span><br><span class="line">      &#x2F;&#x2F; specialPropRefWarningShown 控制错误只输出一次的变量</span><br><span class="line">      if (!specialPropRefWarningShown) &#123;</span><br><span class="line">        &#x2F;&#x2F; 通过 specialPropRefWarningShown 变量锁住判断条件</span><br><span class="line">        specialPropRefWarningShown &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F; 指定报错信息和组件名称</span><br><span class="line">        console.error(</span><br><span class="line">          &#39;%s: &#96;ref&#96; is not a prop. Trying to access it will result &#39; +</span><br><span class="line">            &#39;in &#96;undefined&#96; being returned. If you need to access the same &#39; +</span><br><span class="line">            &#39;value within the child component, you should pass it as a different &#39; +</span><br><span class="line">            &#39;prop. (https:&#x2F;&#x2F;reactjs.org&#x2F;link&#x2F;special-props)&#39;,</span><br><span class="line">          displayName,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  warnAboutAccessingRef.isReactWarning &#x3D; true;</span><br><span class="line">  &#x2F;&#x2F; 为 props 对象添加 key 属性</span><br><span class="line">  Object.defineProperty(props, &#39;ref&#39;, &#123;</span><br><span class="line">    get: warnAboutAccessingRef,</span><br><span class="line">    configurable: true,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-React16版本所采用的架构"><a href="#5-React16版本所采用的架构" class="headerlink" title="5.React16版本所采用的架构"></a>5.React16版本所采用的架构</h3><blockquote>
<p>React 架构</p>
</blockquote>
<p>React 16 版本的架构可以分为三层：调度层、协调层、渲染层。</p>
<ul>
<li>Scheduler (调度层)：调度任务的优先级，高优任务优先进入协调器</li>
<li>Reconciler (协调层)：构建 Fiber 数据结构，比对 Fiber 对象找出差异, 记录 Fiber 对象要进行的 DOM 操作</li>
<li>Renderer (渲染层)：负责将发生变化的部分渲染到页面上</li>
</ul>
<blockquote>
<p>Scheduler 调度层</p>
</blockquote>
<p>在 React 15 的版本中，采用了循环加递归的方式进行了 virtualDOM 的比对，由于递归使用 JavaScript 自身的执行栈，一旦开始就无法停止，直到任务执行完成。如果 VirtualDOM 树的层级比较深，virtualDOM 的比对就会长期占用 JavaScript 主线程，由于 JavaScript 又是单线程的无法同时执行其他任务，所以在比对的过程中无法响应用户操作，无法即时执行元素动画，造成了页面卡顿的现象。</p>
<p>在 React 16 的版本中，放弃了 JavaScript 递归的方式进行 virtualDOM 的比对，而是采用循环模拟递归。而且比对的过程是利用浏览器的空闲时间完成的，不会长期占用主线程，这就解决了 virtualDOM 比对造成页面卡顿的问题。</p>
<p>在 window 对象中提供了 requestIdleCallback API，它可以利用浏览器的空闲时间执行任务，但是它自身也存在一些问题，比如说并不是所有的浏览器都支持它，而且它的触发频率也不是很稳定，所以 React 最终放弃了 requestIdleCallback 的使用。</p>
<p>在 React 中，官方实现了自己的任务调度库，这个库就叫做 Scheduler。它也可以实现在浏览器空闲时执行任务，而且还可以设置任务的优先级，高优先级任务先执行，低优先级任务后执行。</p>
<p>Scheduler 存储在 <code>packages/scheduler</code> 文件夹中。</p>
<blockquote>
<p>Reconciler 协调层</p>
</blockquote>
<p>在 React 15 的版本中，协调器和渲染器交替执行，即找到了差异就直接更新差异。在 React 16 的版本中，这种情况发生了变化，协调器和渲染器不再交替执行。协调器负责找出差异，在所有差异找出之后，统一交给渲染器进行 DOM 的更新。也就是说协调器的主要任务就是找出差异部分，并为差异打上标记。</p>
<blockquote>
<p>Renderer 渲染层</p>
</blockquote>
<p>渲染器根据协调器为 Fiber 节点打的标记，同步执行对应的DOM操作。</p>
<p>既然比对的过程从递归变成了可以中断的循环，那么 React 是如何解决中断更新时 DOM 渲染不完全的问题呢？</p>
<p>其实根本就不存在这个问题，因为在整个过程中，调度器和协调器的工作是在内存中完成的是可以被打断的，渲染器的工作被设定成不可以被打断，所以不存在DOM 渲染不完全的问题。</p>
<h3 id="6-Fiber数据结构介绍"><a href="#6-Fiber数据结构介绍" class="headerlink" title="6.Fiber数据结构介绍"></a>6.Fiber数据结构介绍</h3><blockquote>
<p>Fiber</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">type Fiber &#x3D; &#123;</span><br><span class="line">  &#x2F;************************  DOM 实例相关  *****************************&#x2F;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 标记不同的组件类型, 值详见 WorkTag</span><br><span class="line">  tag: WorkTag,</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 组件类型 div、span、组件构造函数</span><br><span class="line">  type: any,</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 实例对象, 如类组件的实例、原生 dom 实例, 而 function 组件没有实例, 因此该属性是空</span><br><span class="line">  stateNode: any,</span><br><span class="line"> </span><br><span class="line">	&#x2F;************************  构建 Fiber 树相关  ***************************&#x2F;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 指向自己的父级 Fiber 对象</span><br><span class="line">  return: Fiber | null,</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 指向自己的第一个子级 Fiber 对象</span><br><span class="line">  child: Fiber | null,</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 指向自己的下一个兄弟 iber 对象</span><br><span class="line">  sibling: Fiber | null,</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 在 Fiber 树更新的过程中，每个 Fiber 都会有一个跟其对应的 Fiber</span><br><span class="line">  &#x2F;&#x2F; 我们称他为 current &lt;&#x3D;&#x3D;&gt; workInProgress</span><br><span class="line">  &#x2F;&#x2F; 在渲染完成之后他们会交换位置</span><br><span class="line">  &#x2F;&#x2F; alternate 指向当前 Fiber 在 workInProgress 树中的对应 Fiber</span><br><span class="line">	alternate: Fiber | null,</span><br><span class="line">		</span><br><span class="line">  &#x2F;************************  状态数据相关  ********************************&#x2F;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 即将更新的 props</span><br><span class="line">  pendingProps: any, </span><br><span class="line">  &#x2F;&#x2F; 旧的 props</span><br><span class="line">  memoizedProps: any,</span><br><span class="line">  &#x2F;&#x2F; 旧的 state</span><br><span class="line">  memoizedState: any,</span><br><span class="line">		</span><br><span class="line">  &#x2F;************************  副作用相关 ******************************&#x2F;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 该 Fiber 对应的组件产生的状态更新会存放在这个队列里面 </span><br><span class="line">  updateQueue: UpdateQueue&lt;any&gt; | null,</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 用来记录当前 Fiber 要执行的 DOM 操作</span><br><span class="line">  effectTag: SideEffectTag,</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 存储要执行的 DOM 操作</span><br><span class="line">  firstEffect: Fiber | null,</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 单链表用来快速查找下一个 side effect</span><br><span class="line">  nextEffect: Fiber | null,</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 存储 DOM 操作完后的副租用 比如调用生命周期函数或者钩子函数的调用</span><br><span class="line">  lastEffect: Fiber | null,</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 任务的过期时间</span><br><span class="line">  expirationTime: ExpirationTime,</span><br><span class="line">  </span><br><span class="line">	&#x2F;&#x2F; 当前组件及子组件处于何种渲染模式 详见 TypeOfMode</span><br><span class="line">  mode: TypeOfMode,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>WorkTag</p>
</blockquote>
<p><code>文件位置：packages/shared/ReactWorkTags.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">type WorkTag &#x3D;</span><br><span class="line">  | 0</span><br><span class="line">  | 1</span><br><span class="line">  | 2</span><br><span class="line">  | 3</span><br><span class="line">  | 4</span><br><span class="line">  | 5</span><br><span class="line">  | 6</span><br><span class="line">  | 7</span><br><span class="line">  | 8</span><br><span class="line">  | 9</span><br><span class="line">  | 10</span><br><span class="line">  | 11</span><br><span class="line">  | 12</span><br><span class="line">  | 13</span><br><span class="line">  | 14</span><br><span class="line">  | 15</span><br><span class="line">  | 16</span><br><span class="line">  | 17</span><br><span class="line">  | 18</span><br><span class="line">  | 19</span><br><span class="line">  | 20</span><br><span class="line">  | 21</span><br><span class="line">  | 22;</span><br><span class="line"></span><br><span class="line">export const FunctionComponent &#x3D; 0;</span><br><span class="line">export const ClassComponent &#x3D; 1;</span><br><span class="line">export const IndeterminateComponent &#x3D; 2;</span><br><span class="line">export const HostRoot &#x3D; 3;</span><br><span class="line">export const HostPortal &#x3D; 4;</span><br><span class="line">export const HostComponent &#x3D; 5;</span><br><span class="line">export const HostText &#x3D; 6;</span><br><span class="line">export const Fragment &#x3D; 7;</span><br><span class="line">export const Mode &#x3D; 8;</span><br><span class="line">export const ContextConsumer &#x3D; 9;</span><br><span class="line">export const ContextProvider &#x3D; 10;</span><br><span class="line">export const ForwardRef &#x3D; 11;</span><br><span class="line">export const Profiler &#x3D; 12;</span><br><span class="line">export const SuspenseComponent &#x3D; 13;</span><br><span class="line">export const MemoComponent &#x3D; 14;</span><br><span class="line">export const SimpleMemoComponent &#x3D; 15;</span><br><span class="line">export const LazyComponent &#x3D; 16;</span><br><span class="line">export const IncompleteClassComponent &#x3D; 17;</span><br><span class="line">export const DehydratedFragment &#x3D; 18;</span><br><span class="line">export const SuspenseListComponent &#x3D; 19;</span><br><span class="line">export const FundamentalComponent &#x3D; 20;</span><br><span class="line">export const ScopeComponent &#x3D; 21;</span><br><span class="line">export const Block &#x3D; 22;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>TypeOfMode</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactTypeOfMode.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export type TypeOfMode &#x3D; number;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 0 同步渲染模式</span><br><span class="line">export const NoMode &#x3D; 0b0000;</span><br><span class="line">&#x2F;&#x2F; 1 严格模式</span><br><span class="line">export const StrictMode &#x3D; 0b0001;</span><br><span class="line">&#x2F;&#x2F; 10 异步渲染过渡模式</span><br><span class="line">export const BlockingMode &#x3D; 0b0010;</span><br><span class="line">&#x2F;&#x2F; 100 异步渲染模式</span><br><span class="line">export const ConcurrentMode &#x3D; 0b0100;</span><br><span class="line">&#x2F;&#x2F; 1000 性能测试模式</span><br><span class="line">export const ProfileMode &#x3D; 0b1000;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>SideEffectTag</p>
</blockquote>
<p><code>文件位置：packages/shared/ReactSideEffectTags.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">export type SideEffectTag &#x3D; number;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Don&#39;t change these two values. They&#39;re used by React Dev Tools.</span><br><span class="line">export const NoEffect &#x3D; &#x2F;*              *&#x2F; 0b0000000000000; &#x2F;&#x2F; 0</span><br><span class="line">export const PerformedWork &#x3D; &#x2F;*         *&#x2F; 0b0000000000001; &#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; You can change the rest (and add more).</span><br><span class="line">export const Placement &#x3D; &#x2F;*             *&#x2F; 0b0000000000010; &#x2F;&#x2F; 2</span><br><span class="line">export const Update &#x3D; &#x2F;*                *&#x2F; 0b0000000000100; &#x2F;&#x2F; 4</span><br><span class="line">export const PlacementAndUpdate &#x3D; &#x2F;*    *&#x2F; 0b0000000000110; &#x2F;&#x2F; 6</span><br><span class="line">export const Deletion &#x3D; &#x2F;*              *&#x2F; 0b0000000001000; &#x2F;&#x2F; 8</span><br><span class="line">export const ContentReset &#x3D; &#x2F;*          *&#x2F; 0b0000000010000; &#x2F;&#x2F; 16</span><br><span class="line">export const Callback &#x3D; &#x2F;*              *&#x2F; 0b0000000100000; &#x2F;&#x2F; 32</span><br><span class="line">export const DidCapture &#x3D; &#x2F;*            *&#x2F; 0b0000001000000; &#x2F;&#x2F; 64</span><br><span class="line">export const Ref &#x3D; &#x2F;*                   *&#x2F; 0b0000010000000; &#x2F;&#x2F; 128</span><br><span class="line">export const Snapshot &#x3D; &#x2F;*              *&#x2F; 0b0000100000000; &#x2F;&#x2F; 256</span><br><span class="line">export const Passive &#x3D; &#x2F;*               *&#x2F; 0b0001000000000; &#x2F;&#x2F; 512</span><br><span class="line">export const Hydrating &#x3D; &#x2F;*             *&#x2F; 0b0010000000000; &#x2F;&#x2F; 1024</span><br><span class="line">export const HydratingAndUpdate &#x3D; &#x2F;*    *&#x2F; 0b0010000000100; &#x2F;&#x2F; 1028</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Passive &amp; Update &amp; Callback &amp; Ref &amp; Snapshot</span><br><span class="line">export const LifecycleEffectMask &#x3D; &#x2F;*   *&#x2F; 0b0001110100100; &#x2F;&#x2F; 932</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Union of all host effects</span><br><span class="line">export const HostEffectMask &#x3D; &#x2F;*        *&#x2F; 0b0011111111111; &#x2F;&#x2F; 2047</span><br><span class="line"></span><br><span class="line">export const Incomplete &#x3D; &#x2F;*            *&#x2F; 0b0100000000000; &#x2F;&#x2F; 2048</span><br><span class="line">export const ShouldCapture &#x3D; &#x2F;*         *&#x2F; 0b1000000000000; &#x2F;&#x2F; 4096</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Update</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let update: Update&lt;*&gt; &#x3D; &#123;</span><br><span class="line">  expirationTime,</span><br><span class="line">  suspenseConfig,</span><br><span class="line"></span><br><span class="line">  tag: UpdateState,</span><br><span class="line">  payload: null,</span><br><span class="line">  callback: null,</span><br><span class="line"></span><br><span class="line">  next: (null: any),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>UpdateQueue</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const queue: &lt;State&gt; &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F; 上一次更新之后的 state, 作为下一次更新的基础</span><br><span class="line">  baseState: fiber.memoizedState,</span><br><span class="line">  baseQueue: null,</span><br><span class="line">  shared: &#123;</span><br><span class="line">    pending: null,</span><br><span class="line">  &#125;,</span><br><span class="line">  effects: null,</span><br><span class="line">&#125;</span><br><span class="line">fiber.updateQueue &#x3D; queue;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>RootTag</p>
</blockquote>
<p><code>文件位置：packages/shared/ReactRootTags.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export type RootTag &#x3D; 0 | 1 | 2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ReactDOM.render</span><br><span class="line">export const LegacyRoot &#x3D; 0;</span><br><span class="line">&#x2F;&#x2F; ReactDOM.createBlockingRoot</span><br><span class="line">export const BlockingRoot &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F; ReactDOM.createRoot</span><br><span class="line">export const ConcurrentRoot &#x3D; 2;</span><br></pre></td></tr></table></figure>

<h3 id="7-双缓存技术介绍"><a href="#7-双缓存技术介绍" class="headerlink" title="7.双缓存技术介绍"></a>7.双缓存技术介绍</h3><p>在 React 中，DOM 的更新采用了双缓存技术，双缓存技术致力于更快速的 DOM 更新。</p>
<p>什么是双缓存？举个例子，使用 canvas 绘制动画时，在绘制每一帧前都会清除上一帧的画面，清除上一帧需要花费时间，如果当前帧画面计算量又比较大，又需要花费比较长的时间，这就导致上一帧清除到下一帧显示中间会有较长的间隙，就会出现白屏。</p>
<p>为了解决这个问题，我们可以在内存中绘制当前帧动画，绘制完毕后直接用当前帧替换上一帧画面，这样的话在帧画面替换的过程中就会节约非常多的时间，就不会出现白屏问题。这种在内存中构建并直接替换的技术叫做双缓存。</p>
<p>React 使用双缓存技术完成 Fiber 树的构建与替换，实现DOM对象的快速更新。</p>
<p>在 React 中最多会同时存在两棵 Fiber 树，当前在屏幕中显示的内容对应的 Fiber 树叫做 current Fiber 树，当发生更新时，React 会在内存中重新构建一颗新的 Fiber 树，这颗正在构建的 Fiber 树叫做 workInProgress Fiber 树。在双缓存技术中，workInProgress Fiber 树就是即将要显示在页面中的 Fiber 树，当这颗 Fiber 树构建完成后，React 会使用它直接替换 current Fiber 树达到快速更新 DOM 的目的，因为 workInProgress Fiber 树是在内存中构建的所以构建它的速度是非常快的。</p>
<p>一旦 workInProgress Fiber 树在屏幕上呈现，它就会变成 current Fiber 树。</p>
<p>在 current Fiber 节点对象中有一个 alternate 属性指向对应的 workInProgress Fiber 节点对象，在 workInProgress Fiber 节点中有一个 alternate 属性也指向对应的 current Fiber 节点对象。</p>
<h3 id="8-区分fiberRoot和rootFiber"><a href="#8-区分fiberRoot和rootFiber" class="headerlink" title="8.区分fiberRoot和rootFiber"></a>8.区分fiberRoot和rootFiber</h3><p>fiberRoot 表示 Fiber 数据结构对象，是 Fiber 数据结构中的最外层对象</p>
<p>rootFiber 表示组件挂载点对应的 Fiber 对象，比如 React 应用中默认的组件挂载点就是 id 为 root 的 div</p>
<p>fiberRoot 包含 rootFiber，在 fiberRoot 对象中有一个 current 属性，存储 rootFiber</p>
<p>rootFiber 指向 fiberRoot，在 rootFiber 对象中有一个 stateNode 属性，指向 fiberRoot</p>
<p>在 React 应用中 FiberRoot 只有一个，而 rootFiber 可以有多个，因为 render 方法是可以调用多次的</p>
<p>fiberRoot 会记录应用的更新信息，比如协调器在完成工作后，会将工作成果存储在 fiberRoot 中。</p>
<h3 id="9-render方法解析"><a href="#9-render方法解析" class="headerlink" title="9.render方法解析"></a>9.render方法解析</h3><p>要将 React 元素渲染到页面中，分为两个阶段，render 阶段和 commit 阶段。</p>
<p>render 阶段负责创建 Fiber 数据结构并为 Fiber 节点打标记，标记当前 Fiber 节点要进行的 DOM 操作。</p>
<p>commit 阶段负责根据 Fiber 节点标记 ( effectTag ) 进行相应的 DOM 操作。</p>
<blockquote>
<p>render</p>
</blockquote>
<p><code>文件位置：packages/react-dom/src/client/ReactDOMLegacy.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 渲染入口</span><br><span class="line"> * element 要进行渲染的 ReactElement, createElement 方法的返回值</span><br><span class="line"> * container 渲染容器 &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line"> * callback 渲染完成后执行的回调函数</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function render(</span><br><span class="line">  element: React$Element&lt;any&gt;,</span><br><span class="line">  container: Container,</span><br><span class="line">  callback: ?Function,</span><br><span class="line">) &#123;</span><br><span class="line">  &#x2F;&#x2F; 检测 container 是否是符合要求的渲染容器</span><br><span class="line">  &#x2F;&#x2F; 即检测 container 是否是真实的DOM对象</span><br><span class="line">  &#x2F;&#x2F; 如果不符合要求就报错</span><br><span class="line">  invariant(</span><br><span class="line">    isValidContainer(container),</span><br><span class="line">    &#39;Target container is not a DOM element.&#39;,</span><br><span class="line">  );</span><br><span class="line">  return legacyRenderSubtreeIntoContainer(</span><br><span class="line">    &#x2F;&#x2F; 父组件 初始渲染没有父组件 传递 null 占位</span><br><span class="line">    null,</span><br><span class="line">    element,</span><br><span class="line">    container,</span><br><span class="line">    &#x2F;&#x2F; 是否为服务器端渲染 false 不是服务器端渲染 true 是服务器端渲染</span><br><span class="line">    false,</span><br><span class="line">    callback,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>isValidContainer</p>
</blockquote>
<p><code>文件位置：packages/react-dom/src/client/ReactDOMRoot.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 判断 node 是否是符合要求的 DOM 节点</span><br><span class="line"> * 1. node 可以是元素节点</span><br><span class="line"> * 2. node 可以是 document 节点</span><br><span class="line"> * 3. node 可以是 文档碎片节点</span><br><span class="line"> * 4. node 可以是注释节点但注释内容必须是 react-mount-point-unstable</span><br><span class="line"> * 		react 内部会找到注释节点的父级 通过调用父级元素的 insertBefore 方法, 将 element 插入到注释节点的前面</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function isValidContainer(node: mixed): boolean &#123;</span><br><span class="line">  return !!(</span><br><span class="line">    node &amp;&amp;</span><br><span class="line">    (node.nodeType &#x3D;&#x3D;&#x3D; ELEMENT_NODE ||</span><br><span class="line">      node.nodeType &#x3D;&#x3D;&#x3D; DOCUMENT_NODE ||</span><br><span class="line">      node.nodeType &#x3D;&#x3D;&#x3D; DOCUMENT_FRAGMENT_NODE ||</span><br><span class="line">      (node.nodeType &#x3D;&#x3D;&#x3D; COMMENT_NODE &amp;&amp;</span><br><span class="line">        (node: any).nodeValue &#x3D;&#x3D;&#x3D; &#39; react-mount-point-unstable &#39;))</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-创建fiberRoot对象和rootFiber对象"><a href="#10-创建fiberRoot对象和rootFiber对象" class="headerlink" title="10.创建fiberRoot对象和rootFiber对象"></a>10.创建fiberRoot对象和rootFiber对象</h3><blockquote>
<p>legacyRenderSubtreeIntoContainer</p>
</blockquote>
<p><code>文件位置: packages/react-dom/src/client/ReactDOMLegacy.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 将子树渲染到容器中 (初始化 Fiber 数据结构: 创建 fiberRoot 及 rootFiber)</span><br><span class="line"> * parentComponent: 父组件, 初始渲染传入了 null</span><br><span class="line"> * children: render 方法中的第一个参数, 要渲染的 ReactElement</span><br><span class="line"> * container: 渲染容器</span><br><span class="line"> * forceHydrate: true 为服务端渲染, false 为客户端渲染</span><br><span class="line"> * callback: 组件渲染完成后需要执行的回调函数</span><br><span class="line"> **&#x2F;</span><br><span class="line">function legacyRenderSubtreeIntoContainer(</span><br><span class="line">  parentComponent: ?React$Component&lt;any, any&gt;,</span><br><span class="line">  children: ReactNodeList,</span><br><span class="line">  container: Container,</span><br><span class="line">  forceHydrate: boolean,</span><br><span class="line">  callback: ?Function,</span><br><span class="line">) &#123;</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 检测 container 是否已经是初始化过的渲染容器</span><br><span class="line">   * react 在初始渲染时会为最外层容器添加 _reactRootContainer 属性</span><br><span class="line">   * react 会根据此属性进行不同的渲染方式</span><br><span class="line">   * root 不存在 表示初始渲染</span><br><span class="line">   * root 存在 表示更新</span><br><span class="line">   *&#x2F;</span><br><span class="line">  &#x2F;&#x2F; 获取 container 容器对象下是否有 _reactRootContainer 属性</span><br><span class="line">  let root: RootType &#x3D; (container._reactRootContainer: any);</span><br><span class="line">  &#x2F;&#x2F; 即将存储根 Fiber 对象</span><br><span class="line">  let fiberRoot;</span><br><span class="line">  if (!root) &#123;</span><br><span class="line">    &#x2F;&#x2F; 初始渲染</span><br><span class="line">    &#x2F;&#x2F; 初始化根 Fiber 数据结构</span><br><span class="line">    &#x2F;&#x2F; 为 container 容器添加 _reactRootContainer 属性</span><br><span class="line">    &#x2F;&#x2F; 在 _reactRootContainer 对象中有一个属性叫做 _internalRoot</span><br><span class="line">    &#x2F;&#x2F; _internalRoot 属性值即为 FiberRoot 表示根节点 Fiber 数据结构</span><br><span class="line">    &#x2F;&#x2F; legacyCreateRootFromDOMContainer</span><br><span class="line">    &#x2F;&#x2F; createLegacyRoot</span><br><span class="line">    &#x2F;&#x2F; new ReactDOMBlockingRoot -&gt; this._internalRoot</span><br><span class="line">    &#x2F;&#x2F; createRootImpl</span><br><span class="line">    root &#x3D; container._reactRootContainer &#x3D; legacyCreateRootFromDOMContainer(</span><br><span class="line">      container,</span><br><span class="line">      forceHydrate,</span><br><span class="line">    );</span><br><span class="line">    &#x2F;&#x2F; 获取 Fiber Root 对象</span><br><span class="line">    fiberRoot &#x3D; root._internalRoot;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 改变 callback 函数中的 this 指向</span><br><span class="line">     * 使其指向 render 方法第一个参数的真实 DOM 对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F; 如果 callback 参数是函数类型</span><br><span class="line">    if (typeof callback &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">      &#x2F;&#x2F; 使用 originalCallback 存储 callback 函数</span><br><span class="line">      const originalCallback &#x3D; callback;</span><br><span class="line">      &#x2F;&#x2F; 为 callback 参数重新赋值</span><br><span class="line">      callback &#x3D; function () &#123;</span><br><span class="line">        &#x2F;&#x2F; 获取 render 方法第一个参数的真实 DOM 对象</span><br><span class="line">        &#x2F;&#x2F; 实际上就是 id&#x3D;&quot;root&quot; 的 div 的子元素</span><br><span class="line">        &#x2F;&#x2F; rootFiber.child.stateNode</span><br><span class="line">        &#x2F;&#x2F; rootFiber 就是 id&#x3D;&quot;root&quot; 的 div</span><br><span class="line">        const instance &#x3D; getPublicRootInstance(fiberRoot);</span><br><span class="line">        &#x2F;&#x2F; 调用 callback 函数并改变函数内部 this 指向</span><br><span class="line">        originalCallback.call(instance);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 初始化渲染不执行批量更新</span><br><span class="line">    &#x2F;&#x2F; 因为批量更新是异步的是可以被打断的, 但是初始化渲染应该尽快完成不能被打断</span><br><span class="line">    &#x2F;&#x2F; 所以不执行批量更新</span><br><span class="line">    unbatchedUpdates(() &#x3D;&gt; &#123;</span><br><span class="line">      updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 非初始化渲染 即更新</span><br><span class="line">    fiberRoot &#x3D; root._internalRoot;</span><br><span class="line">    if (typeof callback &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">      const originalCallback &#x3D; callback;</span><br><span class="line">      callback &#x3D; function () &#123;</span><br><span class="line">        const instance &#x3D; getPublicRootInstance(fiberRoot);</span><br><span class="line">        originalCallback.call(instance);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Update</span><br><span class="line">    updateContainer(children, fiberRoot, parentComponent, callback);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 返回 render 方法第一个参数的真实 DOM 对象作为 render 方法的返回值</span><br><span class="line">  &#x2F;&#x2F; 就是说渲染谁 返回谁的真实 DOM 对象</span><br><span class="line">  return getPublicRootInstance(fiberRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>legacyCreateRootFromDOMContainer</p>
</blockquote>
<p><code>文件位置: packages/react-dom/src/client/ReactDOMLegacy.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 判断是否为服务器端渲染 如果不是服务器端渲染</span><br><span class="line"> * 清空 container 容器中的节点</span><br><span class="line"> *&#x2F;</span><br><span class="line">function legacyCreateRootFromDOMContainer(</span><br><span class="line">  container: Container,</span><br><span class="line">  forceHydrate: boolean,</span><br><span class="line">): RootType &#123;</span><br><span class="line">  &#x2F;&#x2F; container &#x3D;&gt; &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &#x2F;&#x2F; 检测是否为服务器端渲染</span><br><span class="line">  const shouldHydrate &#x3D;</span><br><span class="line">    forceHydrate || shouldHydrateDueToLegacyHeuristic(container);</span><br><span class="line">  &#x2F;&#x2F; 如果不是服务器端渲染</span><br><span class="line">  if (!shouldHydrate) &#123;</span><br><span class="line">    let rootSibling;</span><br><span class="line">    &#x2F;&#x2F; 开启循环 删除 container 容器中的节点</span><br><span class="line">    while ((rootSibling &#x3D; container.lastChild)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 删除 container 容器中的节点</span><br><span class="line">      container.removeChild(rootSibling);</span><br><span class="line">      &#x2F;**</span><br><span class="line">       * 为什么要清除 container 中的元素 ?</span><br><span class="line">       * 为提供首屏加载的用户体验, 有时需要在 container 中放置一些占位图或者 loading 图</span><br><span class="line">       * 就无可避免的要向 container 中加入 html 标记.</span><br><span class="line">       * 在将 ReactElement 渲染到 container 之前, 必然要先清空 container</span><br><span class="line">       * 因为占位图和 ReactElement 不能同时显示</span><br><span class="line">       *</span><br><span class="line">       * 在加入占位代码时, 最好只有一个父级元素, 可以减少内部代码的循环次数以提高性能</span><br><span class="line">       * &lt;div&gt;</span><br><span class="line">       *  &lt;p&gt;placement&lt;p&gt;</span><br><span class="line">       *  &lt;p&gt;placement&lt;p&gt;</span><br><span class="line">       *  &lt;p&gt;placement&lt;p&gt;</span><br><span class="line">       * &lt;&#x2F;div&gt;</span><br><span class="line">       *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return createLegacyRoot(</span><br><span class="line">    container,</span><br><span class="line">    shouldHydrate</span><br><span class="line">      ? &#123;</span><br><span class="line">          hydrate: true,</span><br><span class="line">        &#125;</span><br><span class="line">      : undefined,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>createLegacyRoot</p>
</blockquote>
<p><code>文件位置: packages/react-dom/src/client/ReactDOMRoot.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 通过实例化 ReactDOMBlockingRoot 类创建 LegacyRoot</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function createLegacyRoot(</span><br><span class="line">  container: Container,</span><br><span class="line">  options?: RootOptions,</span><br><span class="line">): RootType &#123;</span><br><span class="line">  &#x2F;&#x2F; container &#x3D;&gt; &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &#x2F;&#x2F; LegacyRoot 常量, 值为 0,</span><br><span class="line">  &#x2F;&#x2F; 通过 render 方法创建的 container 就是 LegacyRoot</span><br><span class="line">  return new ReactDOMBlockingRoot(container, LegacyRoot, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ReactDOMBlockingRoot</p>
</blockquote>
<p><code>文件位置: packages/react-dom/src/client/ReactDOMRoot.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 类, 通过它可以创建 LegacyRoot 的 Fiber 数据结构</span><br><span class="line"> *&#x2F;</span><br><span class="line">function ReactDOMBlockingRoot(</span><br><span class="line">  container: Container,</span><br><span class="line">  tag: RootTag,</span><br><span class="line">  options: void | RootOptions,</span><br><span class="line">) &#123;</span><br><span class="line">  &#x2F;&#x2F; tag &#x3D;&gt; 0 &#x3D;&gt; legacyRoot</span><br><span class="line">  &#x2F;&#x2F; container &#x3D;&gt; &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &#x2F;&#x2F; container._reactRootContainer &#x3D; &#123;_internalRoot: &#123;&#125;&#125;</span><br><span class="line">  this._internalRoot &#x3D; createRootImpl(container, tag, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>createRootImpl</p>
</blockquote>
<p><code>文件位置: packages/react-dom/src/client/ReactDOMRoot.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function createRootImpl(</span><br><span class="line">  container: Container,</span><br><span class="line">  tag: RootTag,</span><br><span class="line">  options: void | RootOptions,</span><br><span class="line">) &#123;</span><br><span class="line">  &#x2F;&#x2F; container &#x3D;&gt; &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &#x2F;&#x2F; tag &#x3D;&gt; 0</span><br><span class="line">  &#x2F;&#x2F; options &#x3D;&gt; undefined</span><br><span class="line">  const root &#x3D; createContainer(container, tag, hydrate, hydrationCallbacks);</span><br><span class="line">  markContainerAsRoot(root.current, container);</span><br><span class="line">  return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>createContainer</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactFiberReconciler.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建 container</span><br><span class="line">export function createContainer(</span><br><span class="line">  containerInfo: Container,</span><br><span class="line">  tag: RootTag,</span><br><span class="line">  hydrate: boolean,</span><br><span class="line">  hydrationCallbacks: null | SuspenseHydrationCallbacks,</span><br><span class="line">): OpaqueRoot &#123;</span><br><span class="line">  &#x2F;&#x2F; containerInfo &#x3D;&gt; &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &#x2F;&#x2F; tag: 0</span><br><span class="line">  &#x2F;&#x2F; hydrate: false</span><br><span class="line">  &#x2F;&#x2F; hydrationCallbacks: null</span><br><span class="line">  &#x2F;&#x2F; 忽略了和服务器端渲染相关的内容</span><br><span class="line">  return createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>createFiberRoot</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactFiberRoot.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建根节点对应的 fiber 对象</span><br><span class="line">export function createFiberRoot(</span><br><span class="line">  containerInfo: any,</span><br><span class="line">  tag: RootTag,</span><br><span class="line">  hydrate: boolean,</span><br><span class="line">  hydrationCallbacks: null | SuspenseHydrationCallbacks,</span><br><span class="line">): FiberRoot &#123;</span><br><span class="line">  &#x2F;&#x2F; 创建 FiberRoot</span><br><span class="line">  const root: FiberRoot &#x3D; (new FiberRootNode(containerInfo, tag, hydrate): any);</span><br><span class="line">  &#x2F;&#x2F; 创建根节点对应的 rootFiber</span><br><span class="line">  const uninitializedFiber &#x3D; createHostRootFiber(tag);</span><br><span class="line">  &#x2F;&#x2F; 为 fiberRoot 添加 current 属性 值为 rootFiber</span><br><span class="line">  root.current &#x3D; uninitializedFiber;</span><br><span class="line">  &#x2F;&#x2F; 为 rootFiber 添加 stateNode 属性 值为 fiberRoot</span><br><span class="line">  uninitializedFiber.stateNode &#x3D; root;</span><br><span class="line">  &#x2F;&#x2F; 为 fiber 对象添加 updateQueue 属性, 初始化 updateQueue 对象</span><br><span class="line">  &#x2F;&#x2F; updateQueue 用于存放 Update 对象</span><br><span class="line">  &#x2F;&#x2F; Update 对象用于记录组件状态的改变</span><br><span class="line">  initializeUpdateQueue(uninitializedFiber);</span><br><span class="line">  &#x2F;&#x2F; 返回 root</span><br><span class="line">  return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>FiberRootNode</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactFiberRoot.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function FiberRootNode(containerInfo, tag, hydrate) &#123;</span><br><span class="line">  this.tag &#x3D; tag;</span><br><span class="line">  this.current &#x3D; null;</span><br><span class="line">  this.containerInfo &#x3D; containerInfo;</span><br><span class="line">  this.pendingChildren &#x3D; null;</span><br><span class="line">  this.pingCache &#x3D; null;</span><br><span class="line">  this.finishedExpirationTime &#x3D; NoWork;</span><br><span class="line">  this.finishedWork &#x3D; null;</span><br><span class="line">  this.timeoutHandle &#x3D; noTimeout;</span><br><span class="line">  this.context &#x3D; null;</span><br><span class="line">  this.pendingContext &#x3D; null;</span><br><span class="line">  this.hydrate &#x3D; hydrate;</span><br><span class="line">  this.callbackNode &#x3D; null;</span><br><span class="line">  this.callbackPriority &#x3D; NoPriority;</span><br><span class="line">  this.firstPendingTime &#x3D; NoWork;</span><br><span class="line">  this.firstSuspendedTime &#x3D; NoWork;</span><br><span class="line">  this.lastSuspendedTime &#x3D; NoWork;</span><br><span class="line">  this.nextKnownPendingLevel &#x3D; NoWork;</span><br><span class="line">  this.lastPingedTime &#x3D; NoWork;</span><br><span class="line">  this.lastExpiredTime &#x3D; NoWork;</span><br><span class="line">  if (enableSchedulerTracing) &#123;</span><br><span class="line">    this.interactionThreadID &#x3D; unstable_getThreadID();</span><br><span class="line">    this.memoizedInteractions &#x3D; new Set();</span><br><span class="line">    this.pendingInteractionMap &#x3D; new Map();</span><br><span class="line">  &#125;</span><br><span class="line">  if (enableSuspenseCallback) &#123;</span><br><span class="line">    this.hydrationCallbacks &#x3D; null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>initializeUpdateQueue</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactFiberRoot.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export function initializeUpdateQueue&lt;State&gt;(fiber: Fiber): void &#123;</span><br><span class="line">  const queue: UpdateQueue&lt;State&gt; &#x3D; &#123;</span><br><span class="line">    baseState: fiber.memoizedState,</span><br><span class="line">    baseQueue: null,</span><br><span class="line">    shared: &#123;</span><br><span class="line">      pending: null,</span><br><span class="line">    &#125;,</span><br><span class="line">    effects: null,</span><br><span class="line">  &#125;;</span><br><span class="line">  fiber.updateQueue &#x3D; queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-更改-callback-函数内部-this-指向"><a href="#11-更改-callback-函数内部-this-指向" class="headerlink" title="11.更改 callback 函数内部 this 指向"></a>11.更改 callback 函数内部 this 指向</h3><blockquote>
<p> getPublicRootInstance</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactFiberReconciler.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 获取 container 的第一个子元素的实例对象</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function getPublicRootInstance(</span><br><span class="line">  &#x2F;&#x2F; FiberRoot</span><br><span class="line">  container: OpaqueRoot,</span><br><span class="line">): React$Component&lt;any, any&gt; | PublicInstance | null &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取 rootFiber</span><br><span class="line">  const containerFiber &#x3D; container.current;</span><br><span class="line">  &#x2F;&#x2F; 如果 rootFiber 没有子元素</span><br><span class="line">  &#x2F;&#x2F; 指的就是 id&#x3D;&quot;root&quot; 的 div 没有子元素</span><br><span class="line">  if (!containerFiber.child) &#123;</span><br><span class="line">    &#x2F;&#x2F; 返回 null</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 匹配子元素的类型</span><br><span class="line">  switch (containerFiber.child.tag) &#123;</span><br><span class="line">    &#x2F;&#x2F; 普通</span><br><span class="line">    case HostComponent:</span><br><span class="line">      return getPublicInstance(containerFiber.child.stateNode);</span><br><span class="line">    default:</span><br><span class="line">      &#x2F;&#x2F; 返回子元素的真实 DOM 对象</span><br><span class="line">      return containerFiber.child.stateNode;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>getPublicInstance</p>
</blockquote>
<p><code>文件位置: packages/react-dom/src/client/ReactDOMHostConfig.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export function getPublicInstance(instance: Instance): * &#123;</span><br><span class="line">  return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-创建任务并存放于任务队列"><a href="#12-创建任务并存放于任务队列" class="headerlink" title="12.创建任务并存放于任务队列"></a>12.创建任务并存放于任务队列</h3><blockquote>
<p>updateContainer</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactFiberReconciler.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 计算任务的过期时间</span><br><span class="line"> * 再根据任务过期时间创建 Update 任务</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function updateContainer(</span><br><span class="line">	&#x2F;&#x2F; element 要渲染的 ReactElement</span><br><span class="line">  element: ReactNodeList,</span><br><span class="line">  &#x2F;&#x2F; container Fiber Root 对象</span><br><span class="line">  container: OpaqueRoot,</span><br><span class="line">  &#x2F;&#x2F; parentComponent 父组件 初始渲染为 null</span><br><span class="line">  parentComponent: ?React$Component&lt;any, any&gt;,</span><br><span class="line">  &#x2F;&#x2F; ReactElement 渲染完成执行的回调函数</span><br><span class="line">  callback: ?Function,</span><br><span class="line">): ExpirationTime &#123;  </span><br><span class="line">  &#x2F;&#x2F; container 获取 rootFiber</span><br><span class="line">  const current &#x3D; container.current;</span><br><span class="line">  &#x2F;&#x2F; 获取当前距离 react 应用初始化的时间 1073741805</span><br><span class="line">  const currentTime &#x3D; requestCurrentTimeForUpdate();</span><br><span class="line">  &#x2F;&#x2F; 异步加载设置</span><br><span class="line">  const suspenseConfig &#x3D; requestCurrentSuspenseConfig();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 计算过期时间</span><br><span class="line">  &#x2F;&#x2F; 为防止任务因为优先级的原因一直被打断而未能执行</span><br><span class="line">  &#x2F;&#x2F; react 会设置一个过期时间, 当时间到了过期时间的时候</span><br><span class="line">  &#x2F;&#x2F; 如果任务还未执行的话, react 将会强制执行该任务</span><br><span class="line">  &#x2F;&#x2F; 初始化渲染时, 任务同步执行不涉及被打断的问题 1073741823</span><br><span class="line">  const expirationTime &#x3D; computeExpirationForFiber(</span><br><span class="line">    currentTime,</span><br><span class="line">    current,</span><br><span class="line">    suspenseConfig,</span><br><span class="line">  );</span><br><span class="line">  &#x2F;&#x2F; 设置FiberRoot.context, 首次执行返回一个emptyContext, 是一个 &#123;&#125;</span><br><span class="line">  const context &#x3D; getContextForSubtree(parentComponent);</span><br><span class="line">  &#x2F;&#x2F; 初始渲染时 Fiber Root 对象中的 context 属性值为 null</span><br><span class="line">  &#x2F;&#x2F; 所以会进入到 if 中</span><br><span class="line">  if (container.context &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 初始渲染时将 context 属性值设置为 &#123;&#125;</span><br><span class="line">    container.context &#x3D; context;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    container.pendingContext &#x3D; context;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 创建一个待执行任务</span><br><span class="line">  const update &#x3D; createUpdate(expirationTime, suspenseConfig);</span><br><span class="line">  &#x2F;&#x2F; 将要更新的内容挂载到更新对象中的 payload 中</span><br><span class="line">  &#x2F;&#x2F; 将要更新的组件存储在 payload 对象中, 方便后期获取</span><br><span class="line">  update.payload &#x3D; &#123;element&#125;;</span><br><span class="line">  &#x2F;&#x2F; 判断 callback 是否存在</span><br><span class="line">  callback &#x3D; callback &#x3D;&#x3D;&#x3D; undefined ? null : callback;</span><br><span class="line">  &#x2F;&#x2F; 如果 callback 存在</span><br><span class="line">  if (callback !&#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将 callback 挂载到 update 对象中</span><br><span class="line">    &#x2F;&#x2F; 其实就是一层层传递 方便 ReactElement 元素渲染完成调用</span><br><span class="line">    &#x2F;&#x2F; 回调函数执行完成后会被清除 可以在代码的后面加上 return 进行验证</span><br><span class="line">    update.callback &#x3D; callback;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 将 update 对象加入到当前 Fiber 的更新队列当中 (updateQueue)</span><br><span class="line">  enqueueUpdate(current, update);</span><br><span class="line">  &#x2F;&#x2F; 调度和更新 current 对象</span><br><span class="line">  scheduleWork(current, expirationTime);</span><br><span class="line">  &#x2F;&#x2F; 返回过期时间</span><br><span class="line">  return expirationTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>enqueueUpdate</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactUpdateQueue.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将任务(Update)存放于任务队列(updateQueue)中</span><br><span class="line">&#x2F;&#x2F; 创建单向链表结构存放 update, next 用来串联 update</span><br><span class="line">export function enqueueUpdate&lt;State&gt;(fiber: Fiber, update: Update&lt;State&gt;) &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取当前 Fiber 的 更新队列</span><br><span class="line">  const updateQueue &#x3D; fiber.updateQueue;</span><br><span class="line">  &#x2F;&#x2F; 如果更新队列不存在 就返回 null</span><br><span class="line">  if (updateQueue &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 仅发生在 fiber 已经被卸载</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 获取待执行的 Update 任务</span><br><span class="line">  &#x2F;&#x2F; 初始渲染时没有待执行的任务</span><br><span class="line">  const sharedQueue &#x3D; updateQueue.shared;</span><br><span class="line">  const pending &#x3D; sharedQueue.pending;</span><br><span class="line">  &#x2F;&#x2F; 如果没有待执行的 Update 任务</span><br><span class="line">  if (pending &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 这是第一次更新, 创建一个循环列表.</span><br><span class="line">    update.next &#x3D; update;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    update.next &#x3D; pending.next;</span><br><span class="line">    pending.next &#x3D; update;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 将 Update 任务存储在 pending 属性中</span><br><span class="line">  sharedQueue.pending &#x3D; update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-任务执行前的准备工作"><a href="#13-任务执行前的准备工作" class="headerlink" title="13.任务执行前的准备工作"></a>13.任务执行前的准备工作</h3><blockquote>
<p>scheduleUpdateOnFiber</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactFiberWorkLoop.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 判断任务是否为同步 调用同步任务入口</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function scheduleUpdateOnFiber(</span><br><span class="line">  &#x2F;&#x2F; rootFiber</span><br><span class="line">  fiber: Fiber,</span><br><span class="line">  expirationTime: ExpirationTime,</span><br><span class="line">) &#123;</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * fiber: 初始化渲染时为 rootFiber, 即 &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt; 对应的 Fiber 对象</span><br><span class="line">   * expirationTime: 任务过期时间 &#x3D;&gt;1073741823</span><br><span class="line">   *&#x2F;</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 判断是否是无限循环的 update 如果是就报错</span><br><span class="line">   * 在 componentWillUpdate 或者 componentDidUpdate 生命周期函数中重复调用</span><br><span class="line">   * setState 方法时, 可能会发生这种情况, React 限制了嵌套更新的数量以防止无限循环</span><br><span class="line">   * 限制的嵌套更新数量为 50, 可通过 NESTED_UPDATE_LIMIT 全局变量获取</span><br><span class="line">   *&#x2F;</span><br><span class="line">  checkForNestedUpdates();</span><br><span class="line">  &#x2F;&#x2F; 判断任务是否是同步任务 Sync的值为: 1073741823</span><br><span class="line">  if (expirationTime &#x3D;&#x3D;&#x3D; Sync) &#123;</span><br><span class="line">    if (</span><br><span class="line">      &#x2F;&#x2F; 检查是否处于非批量更新模式</span><br><span class="line">      (executionContext &amp; LegacyUnbatchedContext) !&#x3D;&#x3D; NoContext &amp;&amp;</span><br><span class="line">      &#x2F;&#x2F; 检查是否没有处于正在进行渲染的任务</span><br><span class="line">      (executionContext &amp; (RenderContext | CommitContext)) &#x3D;&#x3D;&#x3D; NoContext</span><br><span class="line">    ) &#123;</span><br><span class="line">      &#x2F;&#x2F; 同步任务入口点</span><br><span class="line">      performSyncWorkOnRoot(root);</span><br><span class="line">    &#125;</span><br><span class="line">  &#x2F;&#x2F; 忽略了一些初始化渲染不会得到执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-构建workInProgress-Fiber-树中的rootFiber"><a href="#14-构建workInProgress-Fiber-树中的rootFiber" class="headerlink" title="14.构建workInProgress Fiber 树中的rootFiber"></a>14.构建workInProgress Fiber 树中的rootFiber</h3><blockquote>
<p>performSyncWorkOnRoot</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactFiberWorkLoop.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 进入 render 阶段, 构建 workInProgress Fiber 树</span><br><span class="line">function performSyncWorkOnRoot(root) &#123;</span><br><span class="line">  &#x2F;&#x2F; 参数 root 为 fiberRoot 对象</span><br><span class="line">  &#x2F;&#x2F; 检查是否有过期的任务</span><br><span class="line">  &#x2F;&#x2F; 如果没有过期的任务 值为 0</span><br><span class="line">  &#x2F;&#x2F; 初始化渲染没有过期的任务待执行</span><br><span class="line">  const lastExpiredTime &#x3D; root.lastExpiredTime;</span><br><span class="line">  &#x2F;&#x2F; NoWork 值为 0</span><br><span class="line">  &#x2F;&#x2F; 如果有过期的任务 将过期时间设置为 lastExpiredTime 否则将过期时间设置为 Sync</span><br><span class="line">  &#x2F;&#x2F; 初始渲染过期时间被设置成了 Sync</span><br><span class="line">  const expirationTime &#x3D; lastExpiredTime !&#x3D;&#x3D; NoWork ? lastExpiredTime : Sync;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 如果 root 和 workInProgressRoot 不相等</span><br><span class="line">  &#x2F;&#x2F; 说明 workInProgressRoot 不存在, 说明还没有构建 workInProgress Fiber 树</span><br><span class="line">  &#x2F;&#x2F; workInProgressRoot 为全局变量 默认值为 null, 初始渲染时值为 null</span><br><span class="line">  &#x2F;&#x2F; expirationTime &#x3D;&gt; 1073741823</span><br><span class="line">  &#x2F;&#x2F; renderExpirationTime &#x3D;&gt; 0</span><br><span class="line">  &#x2F;&#x2F; true</span><br><span class="line">  if (root !&#x3D;&#x3D; workInProgressRoot || expirationTime !&#x3D;&#x3D; renderExpirationTime) &#123;</span><br><span class="line">    &#x2F;&#x2F; 构建 workInProgressFiber 树及rootFiber</span><br><span class="line">    prepareFreshStack(root, expirationTime);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; workInProgress 如果不为 null</span><br><span class="line">  if (workInProgress !&#x3D;&#x3D; null) &#123;</span><br><span class="line">    do &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        &#x2F;&#x2F; 以同步的方式开始构建 Fiber 对象</span><br><span class="line">        workLoopSync();</span><br><span class="line">        &#x2F;&#x2F; 跳出 while 循环</span><br><span class="line">        break;</span><br><span class="line">      &#125; catch (thrownValue) &#123;</span><br><span class="line">        handleError(root, thrownValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; while (true);</span><br><span class="line">    </span><br><span class="line">    if (workInProgress !&#x3D;&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 这是一个同步渲染, 所以我们应该完成整棵树.</span><br><span class="line">      &#x2F;&#x2F; 无法提交不完整的 root, 此错误可能是由于React中的错误所致. 请提出问题.</span><br><span class="line">      invariant(</span><br><span class="line">        false,</span><br><span class="line">        &#39;Cannot commit an incomplete root. This error is likely caused by a &#39; +</span><br><span class="line">          &#39;bug in React. Please file an issue.&#39;,</span><br><span class="line">      );</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 将构建好的新 Fiber 对象存储在 finishedWork 属性中</span><br><span class="line">      &#x2F;&#x2F; 提交阶段使用</span><br><span class="line">      root.finishedWork &#x3D; (root.current.alternate: any);</span><br><span class="line">      root.finishedExpirationTime &#x3D; expirationTime;</span><br><span class="line">      &#x2F;&#x2F; 结束 render 阶段</span><br><span class="line">      &#x2F;&#x2F; 进入 commit 阶段</span><br><span class="line">      finishSyncRender(root);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>prepareFreshStack</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactFiberWorkLoop.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 根据 currentFiber 树中的 rootFiber</span><br><span class="line"> * 构建 workInProgressFiber 树中的 rootFiber</span><br><span class="line"> *&#x2F;</span><br><span class="line">function prepareFreshStack(root, expirationTime) &#123;</span><br><span class="line">  &#x2F;&#x2F; 为 FiberRoot 对象添加 finishedWork 属性</span><br><span class="line">  &#x2F;&#x2F; finishedWork 表示 render 阶段执行完成后构建的待提交的 Fiber 对象</span><br><span class="line">  root.finishedWork &#x3D; null;</span><br><span class="line">  &#x2F;&#x2F; 初始化 finishedExpirationTime 值为 0</span><br><span class="line">  root.finishedExpirationTime &#x3D; NoWork;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 建构 workInProgress Fiber 树的 Fiber 对象</span><br><span class="line">  workInProgressRoot &#x3D; root;</span><br><span class="line">  &#x2F;&#x2F; 构建 workInProgress Fiber 树中的 rootFiber</span><br><span class="line">  workInProgress &#x3D; createWorkInProgress(root.current, null);</span><br><span class="line">  renderExpirationTime &#x3D; expirationTime;</span><br><span class="line">  workInProgressRootExitStatus &#x3D; RootIncomplete;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>createWorkInProgress</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactFiber.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 构建 workInProgress Fiber 树中的 rootFiber</span><br><span class="line">&#x2F;&#x2F; 构建完成后会替换 current fiber</span><br><span class="line">&#x2F;&#x2F; 初始渲染 pendingProps 为 null</span><br><span class="line">export function createWorkInProgress(current: Fiber, pendingProps: any): Fiber &#123;</span><br><span class="line">  &#x2F;&#x2F; current: current Fiber 中的 rootFiber</span><br><span class="line">  &#x2F;&#x2F; 获取 current Fiber 中对应的 workInProgress Fiber</span><br><span class="line">  let workInProgress &#x3D; current.alternate;</span><br><span class="line">  &#x2F;&#x2F; 如果 workInProgress 不存在</span><br><span class="line">  if (workInProgress &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建 fiber 对象</span><br><span class="line">    workInProgress &#x3D; createFiber(</span><br><span class="line">      current.tag,</span><br><span class="line">      pendingProps,</span><br><span class="line">      current.key,</span><br><span class="line">      current.mode,</span><br><span class="line">    );</span><br><span class="line">    &#x2F;&#x2F; 属性复用</span><br><span class="line">    workInProgress.elementType &#x3D; current.elementType;</span><br><span class="line">    workInProgress.type &#x3D; current.type;</span><br><span class="line">    workInProgress.stateNode &#x3D; current.stateNode;</span><br><span class="line">    &#x2F;&#x2F; 使用 alternate 存储 current</span><br><span class="line">    workInProgress.alternate &#x3D; current;</span><br><span class="line">    &#x2F;&#x2F; 使用 alternate 存储 workInProgress</span><br><span class="line">    current.alternate &#x3D; workInProgress;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  workInProgress.childExpirationTime &#x3D; current.childExpirationTime;</span><br><span class="line">  workInProgress.expirationTime &#x3D; current.expirationTime;</span><br><span class="line">  workInProgress.child &#x3D; current.child;</span><br><span class="line">  workInProgress.memoizedProps &#x3D; current.memoizedProps;</span><br><span class="line">  workInProgress.memoizedState &#x3D; current.memoizedState;</span><br><span class="line">  workInProgress.updateQueue &#x3D; current.updateQueue;</span><br><span class="line">  workInProgress.sibling &#x3D; current.sibling;</span><br><span class="line">  workInProgress.index &#x3D; current.index;</span><br><span class="line">  workInProgress.ref &#x3D; current.ref;</span><br><span class="line">	</span><br><span class="line">  &#x2F;&#x2F; 返回创建好的 workInProgress Fiber 对象</span><br><span class="line">  return workInProgress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-workLoopSync方法解析"><a href="#15-workLoopSync方法解析" class="headerlink" title="15.workLoopSync方法解析"></a>15.workLoopSync方法解析</h3><blockquote>
<p>workLoopSync</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactFiberWorkLoop.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 以同步的方式构建 workInProgress Fiber 对象</span><br><span class="line">function workLoopSync() &#123;</span><br><span class="line">  &#x2F;&#x2F; workInProgress 是一个 fiber 对象</span><br><span class="line">  &#x2F;&#x2F; 它的值不为 null 意味着该 fiber 对象上仍然有更新要执行</span><br><span class="line">  while (workInProgress !&#x3D;&#x3D; null) &#123;</span><br><span class="line">    workInProgress &#x3D; performUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="16-performUnitOfWork方法解析"><a href="#16-performUnitOfWork方法解析" class="headerlink" title="16.performUnitOfWork方法解析"></a>16.performUnitOfWork方法解析</h3><blockquote>
<p>performUnitOfWork</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactFiberWorkLoop.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function performUnitOfWork(unitOfWork: Fiber): Fiber | null &#123;</span><br><span class="line">  &#x2F;&#x2F; unitOfWork &#x3D;&gt; workInProgress Fiber 树中的 rootFiber</span><br><span class="line">  &#x2F;&#x2F; current &#x3D;&gt; currentFiber 树中的 rootFiber</span><br><span class="line">  const current &#x3D; unitOfWork.alternate;</span><br><span class="line">  &#x2F;&#x2F; 存储下一个要构建的子级 Fiber 对象</span><br><span class="line">  let next;</span><br><span class="line">  &#x2F;&#x2F; false</span><br><span class="line">  if (enableProfilerTimer &amp;&amp; (unitOfWork.mode &amp; ProfileMode) !&#x3D;&#x3D; NoMode) &#123;</span><br><span class="line">    &#x2F;&#x2F; 初始渲染 不执行</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; beginWork: 从父到子, 构建 Fiber 节点对象</span><br><span class="line">    &#x2F;&#x2F; 返回值 next 为当前节点的子节点</span><br><span class="line">    next &#x3D; beginWork(current, unitOfWork, renderExpirationTime);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 为旧的 props 属性赋值</span><br><span class="line">  &#x2F;&#x2F; 此次更新后 pendingProps 变为 memoizedProps</span><br><span class="line">  unitOfWork.memoizedProps &#x3D; unitOfWork.pendingProps;</span><br><span class="line">  &#x2F;&#x2F; 如果子节点不存在说明当前节点向下遍历子节点已经到底了</span><br><span class="line">  &#x2F;&#x2F; 继续向上返回 遇到兄弟节点 构建兄弟节点的子 Fiber 对象 直到返回到根 Fiber 对象</span><br><span class="line">  if (next &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 从子到父, 构建其余节点 Fiber 对象</span><br><span class="line">    next &#x3D; completeUnitOfWork(unitOfWork);</span><br><span class="line">  &#125;</span><br><span class="line">  return next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-构建单个子级Fiber对象的情况"><a href="#17-构建单个子级Fiber对象的情况" class="headerlink" title="17.构建单个子级Fiber对象的情况"></a>17.构建单个子级Fiber对象的情况</h3><blockquote>
<p>reconcileChildren</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactFiberBeginWork.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">export function reconcileChildren(</span><br><span class="line">  &#x2F;&#x2F; 旧 Fiber</span><br><span class="line">  current: Fiber | null,</span><br><span class="line">  &#x2F;&#x2F; 父级 Fiber</span><br><span class="line">  workInProgress: Fiber,</span><br><span class="line">  &#x2F;&#x2F; 子级 vdom 对象</span><br><span class="line">  nextChildren: any,</span><br><span class="line">  &#x2F;&#x2F; 初始渲染 整型最大值 代表同步任务</span><br><span class="line">  renderExpirationTime: ExpirationTime,</span><br><span class="line">) &#123;</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 为什么要传递 current ?</span><br><span class="line">   * 如果不是初始渲染的情况, 要进行新旧 Fiber 对比</span><br><span class="line">   * 初始渲染时则用不到 current</span><br><span class="line">   *&#x2F;</span><br><span class="line">  &#x2F;&#x2F; 如果就 Fiber 为 null 表示初始渲染</span><br><span class="line">  if (current &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 为当前构建的 Fiber 对象添加子级 Fiber 对象</span><br><span class="line">    workInProgress.child &#x3D; mountChildFibers(</span><br><span class="line">      workInProgress,</span><br><span class="line">      null,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderExpirationTime,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 忽略了 else 的情况</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ChildReconciler</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactChildFiber.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * shouldTrackSideEffects 标识, 是否为 Fiber 对象添加 effectTag</span><br><span class="line"> * true 添加 false 不添加</span><br><span class="line"> * 对于初始渲染来说, 只有根组件需要添加, 其他元素不需要添加, 防止过多的 DOM 操作</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;&#x2F; 用于初始渲染</span><br><span class="line">export const mountChildFibers &#x3D; ChildReconciler(false);</span><br><span class="line"></span><br><span class="line">function ChildReconciler(shouldTrackSideEffects) &#123;</span><br><span class="line"> </span><br><span class="line">  function placeChild(</span><br><span class="line">    newFiber: Fiber,</span><br><span class="line">    lastPlacedIndex: number,</span><br><span class="line">    newIndex: number,</span><br><span class="line">  ): number &#123;</span><br><span class="line">    newFiber.index &#x3D; newIndex;</span><br><span class="line">    if (!shouldTrackSideEffects) &#123;</span><br><span class="line">      return lastPlacedIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 忽略了一部分初始化渲染不执行的代码</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function placeSingleChild(newFiber: Fiber): Fiber &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果是初始渲染 会在根组件(App)上设置 effectTag 属性为 Placement 值为 1</span><br><span class="line">    &#x2F;&#x2F; 其他子级节点具有默认值为 0 防止在 commit 阶段反复操作真实DOM</span><br><span class="line">    &#x2F;&#x2F; 初始渲染时如果当前处理的是根组件 true 其他组件 false</span><br><span class="line">    if (shouldTrackSideEffects &amp;&amp; newFiber.alternate &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; Placement 表示新创建的节点</span><br><span class="line">      newFiber.effectTag &#x3D; Placement;</span><br><span class="line">    &#125;</span><br><span class="line">    return newFiber;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 处理子元素是数组的情况</span><br><span class="line">  function reconcileChildrenArray(</span><br><span class="line">    &#x2F;&#x2F; 父级 Fiber</span><br><span class="line">    returnFiber: Fiber,</span><br><span class="line">    currentFirstChild: Fiber | null,</span><br><span class="line">    &#x2F;&#x2F; 子级 vdom 数组</span><br><span class="line">    newChildren: Array&lt;*&gt;,</span><br><span class="line">    expirationTime: ExpirationTime,</span><br><span class="line">  ): Fiber | null &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 存储第一个子节点 Fiber 对象</span><br><span class="line">     * 方法返回的也是第一个子节点 Fiber 对象</span><br><span class="line">     * 因为其他子节点 Fiber 对象都存储在上一个子 Fiber 节点对象的 sibling 属性中</span><br><span class="line">     *&#x2F;</span><br><span class="line">    let resultingFirstChild: Fiber | null &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; 上一次创建的 Fiber 对象</span><br><span class="line">    let previousNewFiber: Fiber | null &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; 初始渲染没有旧的子级 所以为 null</span><br><span class="line">    let oldFiber &#x3D; currentFirstChild;</span><br><span class="line"></span><br><span class="line">    let lastPlacedIndex &#x3D; 0;</span><br><span class="line">    let newIdx &#x3D; 0;</span><br><span class="line">    let nextOldFiber &#x3D; null;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; oldFiber 为空 说明是初始渲染</span><br><span class="line">    if (oldFiber &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 遍历子 vdom 对象</span><br><span class="line">      for (; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建子 vdom 对应的 fiber 对象</span><br><span class="line">        const newFiber &#x3D; createChild(</span><br><span class="line">          returnFiber,</span><br><span class="line">          newChildren[newIdx],</span><br><span class="line">          expirationTime,</span><br><span class="line">        );</span><br><span class="line">        &#x2F;&#x2F; 如果 newFiber 为 null</span><br><span class="line">        if (newFiber &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">          &#x2F;&#x2F; 进入下次循环</span><br><span class="line">          continue;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 初始渲染时只为 newFiber 添加了 index 属性,</span><br><span class="line">        &#x2F;&#x2F; 其他事没干. lastPlacedIndex 被原封不动的返回了</span><br><span class="line">        lastPlacedIndex &#x3D; placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">        &#x2F;&#x2F; 为当前节点设置下一个兄弟节点</span><br><span class="line">        if (previousNewFiber &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">          &#x2F;&#x2F; 存储第一个子 Fiber 发生在第一次循环时</span><br><span class="line">          resultingFirstChild &#x3D; newFiber;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          &#x2F;&#x2F; 为节点设置下一个兄弟 Fiber</span><br><span class="line">          previousNewFiber.sibling &#x3D; newFiber;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 在循环的过程中更新上一个创建的Fiber 对象</span><br><span class="line">        previousNewFiber &#x3D; newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 返回创建好的子 Fiber</span><br><span class="line">      &#x2F;&#x2F; 其他 Fiber 都作为 sibling 存在</span><br><span class="line">      return resultingFirstChild;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 返回第一个子元素 Fiber 对象</span><br><span class="line">    return resultingFirstChild;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 处理子元素是文本或者数值的情况</span><br><span class="line">  function reconcileSingleTextNode(</span><br><span class="line">    returnFiber: Fiber,</span><br><span class="line">    currentFirstChild: Fiber | null,</span><br><span class="line">    textContent: string,</span><br><span class="line">    expirationTime: ExpirationTime,</span><br><span class="line">  ): Fiber &#123;</span><br><span class="line">    &#x2F;&#x2F; 初始渲染不执行</span><br><span class="line">    if (currentFirstChild !&#x3D;&#x3D; null &amp;&amp; currentFirstChild.tag &#x3D;&#x3D;&#x3D; HostText) &#123;</span><br><span class="line">      &#x2F;&#x2F; We already have an existing node so let&#39;s just update it and delete</span><br><span class="line">      &#x2F;&#x2F; the rest.</span><br><span class="line">      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);</span><br><span class="line">      const existing &#x3D; useFiber(currentFirstChild, textContent);</span><br><span class="line">      existing.return &#x3D; returnFiber;</span><br><span class="line">      return existing;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 现有的第一个子节点不是文本节点，因此我们需要创建一个并删除现有的.</span><br><span class="line">    &#x2F;&#x2F; 初始渲染不执行</span><br><span class="line">    deleteRemainingChildren(returnFiber, currentFirstChild);</span><br><span class="line">    &#x2F;&#x2F; 根据文本创建 Fiber 对象</span><br><span class="line">    const created &#x3D; createFiberFromText(</span><br><span class="line">      textContent,</span><br><span class="line">      returnFiber.mode,</span><br><span class="line">      expirationTime,</span><br><span class="line">    );</span><br><span class="line">    &#x2F;&#x2F; 设置父 Fiber 对象</span><br><span class="line">    created.return &#x3D; returnFiber;</span><br><span class="line">    &#x2F;&#x2F; 返回创建好的 Fiber 对象</span><br><span class="line">    return created;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 处理子元素是单个对象的情况</span><br><span class="line">  function reconcileSingleElement(</span><br><span class="line">    &#x2F;&#x2F; 父 Fiber 对象</span><br><span class="line">    returnFiber: Fiber,</span><br><span class="line">    &#x2F;&#x2F; 备份子 fiber</span><br><span class="line">    currentFirstChild: Fiber | null,</span><br><span class="line">    &#x2F;&#x2F; 子 vdom 对象</span><br><span class="line">    element: ReactElement,</span><br><span class="line">    expirationTime: ExpirationTime,</span><br><span class="line">  ): Fiber &#123;</span><br><span class="line">    &#x2F;&#x2F; 查看子 vdom 对象是否表示 fragment</span><br><span class="line">    if (element.type &#x3D;&#x3D;&#x3D; REACT_FRAGMENT_TYPE) &#123;</span><br><span class="line">      &#x2F;&#x2F; false</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 根据 React Element 创建 Fiber 对象</span><br><span class="line">      &#x2F;&#x2F; 返回创建好的 Fiber 对象</span><br><span class="line">      const created &#x3D; createFiberFromElement(</span><br><span class="line">        element,</span><br><span class="line">        &#x2F;&#x2F; 用来表示当前组件下的所有子组件要用处于何种渲染模式</span><br><span class="line">        &#x2F;&#x2F; 文件位置: .&#x2F;ReactTypeOfMode.js</span><br><span class="line">        &#x2F;&#x2F; 0    同步渲染模式</span><br><span class="line">        &#x2F;&#x2F; 100  异步渲染模式</span><br><span class="line">        returnFiber.mode,</span><br><span class="line">        expirationTime,</span><br><span class="line">      );</span><br><span class="line">      &#x2F;&#x2F; 添加 ref 属性 &#123; current: DOM &#125;</span><br><span class="line">      created.ref &#x3D; coerceRef(returnFiber, currentFirstChild, element);</span><br><span class="line">      &#x2F;&#x2F; 添加父级 Fiber 对象</span><br><span class="line">      created.return &#x3D; returnFiber;</span><br><span class="line">      &#x2F;&#x2F; 返回创建好的子 Fiber</span><br><span class="line">      return created;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function reconcileChildFibers(</span><br><span class="line">    &#x2F;&#x2F; 父 Fiber 对象</span><br><span class="line">    returnFiber: Fiber,</span><br><span class="line">    &#x2F;&#x2F; 旧的第一个子 Fiber 初始渲染 null</span><br><span class="line">    currentFirstChild: Fiber | null,</span><br><span class="line">    &#x2F;&#x2F; 新的子 vdom 对象</span><br><span class="line">    newChild: any,</span><br><span class="line">    &#x2F;&#x2F; 初始渲染 整型最大值 代表同步任务</span><br><span class="line">    expirationTime: ExpirationTime,</span><br><span class="line">  ): Fiber | null &#123;</span><br><span class="line">    &#x2F;&#x2F; 这是入口方法, 根据 newChild 类型进行对应处理</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 判断新的子 vdom 是否为占位组件 比如 &lt;&gt;&lt;&#x2F;&gt;</span><br><span class="line">    &#x2F;&#x2F; false</span><br><span class="line">    const isUnkeyedTopLevelFragment &#x3D;</span><br><span class="line">      typeof newChild &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp;</span><br><span class="line">      newChild !&#x3D;&#x3D; null &amp;&amp;</span><br><span class="line">      newChild.type &#x3D;&#x3D;&#x3D; REACT_FRAGMENT_TYPE &amp;&amp;</span><br><span class="line">      newChild.key &#x3D;&#x3D;&#x3D; null;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果 newChild 为占位符, 使用 占位符组件的子元素作为 newChild</span><br><span class="line">    if (isUnkeyedTopLevelFragment) &#123;</span><br><span class="line">      newChild &#x3D; newChild.props.children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 检测 newChild 是否为对象类型</span><br><span class="line">    const isObject &#x3D; typeof newChild &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; newChild !&#x3D;&#x3D; null;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; newChild 是单个对象的情况</span><br><span class="line">    if (isObject) &#123;</span><br><span class="line">      &#x2F;&#x2F; 匹配子元素的类型</span><br><span class="line">      switch (newChild.$$typeof) &#123;</span><br><span class="line">        &#x2F;&#x2F; 子元素为 ReactElement</span><br><span class="line">        case REACT_ELEMENT_TYPE:</span><br><span class="line">          &#x2F;&#x2F; 为 Fiber 对象设置 effectTag 属性</span><br><span class="line">          &#x2F;&#x2F; 返回创建好的子 Fiber</span><br><span class="line">          return placeSingleChild(</span><br><span class="line">            &#x2F;&#x2F; 处理单个 React Element 的情况</span><br><span class="line">            &#x2F;&#x2F; 内部会调用其他方法创建对应的 Fiber 对象</span><br><span class="line">            reconcileSingleElement(</span><br><span class="line">              returnFiber,</span><br><span class="line">              currentFirstChild,</span><br><span class="line">              newChild,</span><br><span class="line">              expirationTime,</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    &#x2F;&#x2F; 处理 children 为文本和数值的情况 return &quot;App works&quot;</span><br><span class="line">    if (typeof newChild &#x3D;&#x3D;&#x3D; &#39;string&#39; || typeof newChild &#x3D;&#x3D;&#x3D; &#39;number&#39;) &#123;</span><br><span class="line">      return placeSingleChild(</span><br><span class="line">        reconcileSingleTextNode(</span><br><span class="line">          returnFiber,</span><br><span class="line">          currentFirstChild,</span><br><span class="line">          &#x2F;&#x2F; 如果 newChild 是数值, 转换为字符串</span><br><span class="line">          &#39;&#39; + newChild,</span><br><span class="line">          expirationTime,</span><br><span class="line">        ),</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; children 是数组的情况</span><br><span class="line">    if (isArray(newChild)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 返回创建好的子 Fiber</span><br><span class="line">      return reconcileChildrenArray(</span><br><span class="line">        returnFiber,</span><br><span class="line">        currentFirstChild,</span><br><span class="line">        newChild,</span><br><span class="line">        expirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-构建多个子级Fiber对象"><a href="#18-构建多个子级Fiber对象" class="headerlink" title="18.构建多个子级Fiber对象"></a>18.构建多个子级Fiber对象</h3><h3 id="19-子级节点Fiber对象的构建流程"><a href="#19-子级节点Fiber对象的构建流程" class="headerlink" title="19.子级节点Fiber对象的构建流程"></a>19.子级节点Fiber对象的构建流程</h3><blockquote>
<p>beginWork</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactFiberBeginWork.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 从父到子, 构建 Fiber 节点对象</span><br><span class="line">function beginWork(</span><br><span class="line">  current: Fiber | null,</span><br><span class="line">  workInProgress: Fiber,</span><br><span class="line">  renderExpirationTime: ExpirationTime,</span><br><span class="line">): Fiber | null &#123;</span><br><span class="line">  &#x2F;&#x2F; NoWork 常量 值为0 清空过期时间</span><br><span class="line">  workInProgress.expirationTime &#x3D; NoWork;</span><br><span class="line">  &#x2F;&#x2F; 根据当前 Fiber 的类型决定如何构建起子级 Fiber 对象</span><br><span class="line">  &#x2F;&#x2F; 文件位置: shared&#x2F;ReactWorkTags.js</span><br><span class="line">  switch (workInProgress.tag) &#123;</span><br><span class="line">    &#x2F;&#x2F; 2</span><br><span class="line">    &#x2F;&#x2F; 函数型组件在第一次渲染组件时使用</span><br><span class="line">    case IndeterminateComponent: &#123;</span><br><span class="line">      return mountIndeterminateComponent(</span><br><span class="line">        &#x2F;&#x2F; 旧 Fiber</span><br><span class="line">        current,</span><br><span class="line">        &#x2F;&#x2F; 新 Fiber</span><br><span class="line">        workInProgress,</span><br><span class="line">        &#x2F;&#x2F; 新 Fiber 的 type 值 初始渲染时是App组件函数</span><br><span class="line">        workInProgress.type,</span><br><span class="line">        &#x2F;&#x2F; 同步 整数最大值 1073741823</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 0</span><br><span class="line">    case FunctionComponent: &#123;</span><br><span class="line">      const Component &#x3D; workInProgress.type;</span><br><span class="line">      const unresolvedProps &#x3D; workInProgress.pendingProps;</span><br><span class="line">      const resolvedProps &#x3D;</span><br><span class="line">        workInProgress.elementType &#x3D;&#x3D;&#x3D; Component</span><br><span class="line">          ? unresolvedProps</span><br><span class="line">          : resolveDefaultProps(Component, unresolvedProps);</span><br><span class="line">      return updateFunctionComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        Component,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 1</span><br><span class="line">    case ClassComponent: &#123;</span><br><span class="line">      const Component &#x3D; workInProgress.type;</span><br><span class="line">      const unresolvedProps &#x3D; workInProgress.pendingProps;</span><br><span class="line">      const resolvedProps &#x3D;</span><br><span class="line">        workInProgress.elementType &#x3D;&#x3D;&#x3D; Component</span><br><span class="line">          ? unresolvedProps</span><br><span class="line">          : resolveDefaultProps(Component, unresolvedProps);</span><br><span class="line">      return updateClassComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        Component,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderExpirationTime,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 3</span><br><span class="line">    case HostRoot:</span><br><span class="line">      return updateHostRoot(current, workInProgress, renderExpirationTime);</span><br><span class="line">    &#x2F;&#x2F; 5</span><br><span class="line">    case HostComponent:</span><br><span class="line">      return updateHostComponent(current, workInProgress, renderExpirationTime);</span><br><span class="line">    &#x2F;&#x2F; 6</span><br><span class="line">    case HostText:</span><br><span class="line">      return updateHostText(current, workInProgress);</span><br><span class="line">  &#x2F;&#x2F; 组件类型未知 报错</span><br><span class="line">  invariant(</span><br><span class="line">    false,</span><br><span class="line">    &#39;Unknown unit of work tag (%s). This error is likely caused by a bug in &#39; +</span><br><span class="line">      &#39;React. Please file an issue.&#39;,</span><br><span class="line">    workInProgress.tag,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>updateHostRoot</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactFiberBeginWork.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HostRoot &#x3D;&gt; &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt; 对应的 Fiber 对象</span><br><span class="line">&#x2F;&#x2F; 找出 HostRoot 的子 ReactElement 并为其构建 Fiber 对象</span><br><span class="line">function updateHostRoot(current, workInProgress, renderExpirationTime) &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取更新队列</span><br><span class="line">  const updateQueue &#x3D; workInProgress.updateQueue;</span><br><span class="line">  &#x2F;&#x2F; 获取新的 props 对象 null</span><br><span class="line">  const nextProps &#x3D; workInProgress.pendingProps;</span><br><span class="line">  &#x2F;&#x2F; 获取上一次渲染使用的 state null</span><br><span class="line">  const prevState &#x3D; workInProgress.memoizedState;</span><br><span class="line">  &#x2F;&#x2F; 获取上一次渲染使用的 children null</span><br><span class="line">  const prevChildren &#x3D; prevState !&#x3D;&#x3D; null ? prevState.element : null;</span><br><span class="line">  &#x2F;&#x2F; 浅复制更新队列, 防止引用属性互相影响</span><br><span class="line">  &#x2F;&#x2F; workInProgress.updateQueue 浅拷贝 current.updateQueue</span><br><span class="line">  cloneUpdateQueue(current, workInProgress);</span><br><span class="line">  &#x2F;&#x2F; 获取 updateQueue.payload 并赋值到 workInProgress.memoizedState</span><br><span class="line">  &#x2F;&#x2F; 要更新的内容就是 element 就是 rootFiber 的子元素</span><br><span class="line">  processUpdateQueue(workInProgress, nextProps, null, renderExpirationTime);</span><br><span class="line">  &#x2F;&#x2F; 获取 element 所在对象</span><br><span class="line">  const nextState &#x3D; workInProgress.memoizedState;</span><br><span class="line">  &#x2F;&#x2F; 从对象中获取 element</span><br><span class="line">  const nextChildren &#x3D; nextState.element;</span><br><span class="line">  &#x2F;&#x2F; 获取 fiberRoot 对象</span><br><span class="line">  const root: FiberRoot &#x3D; workInProgress.stateNode;</span><br><span class="line">  &#x2F;&#x2F; 服务器端渲染走 if</span><br><span class="line">  if (root.hydrate &amp;&amp; enterHydrationState(workInProgress)) &#123;</span><br><span class="line">    &#x2F;&#x2F; 忽略</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 客户端渲染走 else</span><br><span class="line">    &#x2F;&#x2F; 构建子节点 fiber 对象</span><br><span class="line">    reconcileChildren(</span><br><span class="line">      current,</span><br><span class="line">      workInProgress,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderExpirationTime,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 返回子节点 fiber 对象</span><br><span class="line">  return workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-completeUnitOfWork方法解析"><a href="#20-completeUnitOfWork方法解析" class="headerlink" title="20.completeUnitOfWork方法解析"></a>20.completeUnitOfWork方法解析</h3><blockquote>
<p>completeUnitOfWork</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactFiberWorkLoop.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> *</span><br><span class="line"> * 从下至上移动到该节点的兄弟节点, 如果一直往上没有兄弟节点就返回父节点, 最终会到达 root 节点</span><br><span class="line"> * 1. 创建其他节点的 Fiber 对象</span><br><span class="line"> * 2. 创建每一个节点的真实 DOM 对象并将其添加到 stateNode 属性中</span><br><span class="line"> * 3. 构建 effect 链表结构</span><br><span class="line"> *&#x2F;</span><br><span class="line">function completeUnitOfWork(unitOfWork: Fiber): Fiber | null &#123;</span><br><span class="line">  &#x2F;&#x2F; 为 workInProgress 全局变量重新赋值</span><br><span class="line">  workInProgress &#x3D; unitOfWork;</span><br><span class="line">  do &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取备份节点</span><br><span class="line">    &#x2F;&#x2F; 初始化渲染 非根 Fiber 对象没有备份节点 所以 current 为 null</span><br><span class="line">    const current &#x3D; workInProgress.alternate;</span><br><span class="line">    &#x2F;&#x2F; 父级 Fiber 对象, 非根 Fiber 对象都有父级</span><br><span class="line">    const returnFiber &#x3D; workInProgress.return;</span><br><span class="line">    &#x2F;&#x2F; 判断传入的 Fiber 对象是否构建完成, 任务调度相关</span><br><span class="line">    &#x2F;&#x2F; &amp; 是表示位的与运算, 把左右两边的数字转化为二进制</span><br><span class="line">    &#x2F;&#x2F; 然后每一位分别进行比较, 如果相等就为1, 不相等即为0</span><br><span class="line">    &#x2F;&#x2F; 此处应用&quot;位与&quot;运算符的目的是&quot;清零&quot;</span><br><span class="line">    &#x2F;&#x2F; true</span><br><span class="line">    if ((workInProgress.effectTag &amp; Incomplete) &#x3D;&#x3D;&#x3D; NoEffect) &#123;</span><br><span class="line">      let next;</span><br><span class="line">      &#x2F;&#x2F; 如果不能使用分析器的 timer, 直接执行 completeWork</span><br><span class="line">      &#x2F;&#x2F; enableProfilerTimer &#x3D;&gt; true</span><br><span class="line">      &#x2F;&#x2F; 但此处无论条件是否成立都会执行 completeWork</span><br><span class="line">      if (</span><br><span class="line">        !enableProfilerTimer ||</span><br><span class="line">        (workInProgress.mode &amp; ProfileMode) &#x3D;&#x3D;&#x3D; NoMode</span><br><span class="line">      ) &#123;</span><br><span class="line">        &#x2F;&#x2F; 重点代码(二)</span><br><span class="line">        &#x2F;&#x2F; 创建节点真实 DOM 对象并将其添加到 stateNode 属性中</span><br><span class="line">        next &#x3D; completeWork(current, workInProgress, renderExpirationTime);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建节点真实 DOM 对象并将其添加到 stateNode 属性中</span><br><span class="line">        next &#x3D; completeWork(current, workInProgress, renderExpirationTime);</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 重点代码(一)</span><br><span class="line">      &#x2F;&#x2F; 如果子级存在</span><br><span class="line">      if (next !&#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 返回子级 一直返回到 workLoopSync</span><br><span class="line">        &#x2F;&#x2F; 再重新执行 performUnitOfWork 构建子级 Fiber 节点对象</span><br><span class="line">        return next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 构建 effect 链表结构</span><br><span class="line">      &#x2F;&#x2F; 如果不是根 Fiber 就是 true 否则就是 false</span><br><span class="line">      &#x2F;&#x2F; 将子树和此 Fiber 的所有 effect 附加到父级的 effect 列表中</span><br><span class="line">      if (</span><br><span class="line">        &#x2F;&#x2F; 如果父 Fiber 存在 并且</span><br><span class="line">        returnFiber !&#x3D;&#x3D; null &amp;&amp;</span><br><span class="line">        &#x2F;&#x2F; 父 Fiber 对象中的 effectTag 为 0</span><br><span class="line">        (returnFiber.effectTag &amp; Incomplete) &#x3D;&#x3D;&#x3D; NoEffect</span><br><span class="line">      ) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将子树和此 Fiber 的所有副作用附加到父级的 effect 列表上</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 以下两个判断的作用是搜集子 Fiber的 effect 到父 Fiber</span><br><span class="line">        if (returnFiber.firstEffect &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">          &#x2F;&#x2F; first</span><br><span class="line">          returnFiber.firstEffect &#x3D; workInProgress.firstEffect;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (workInProgress.lastEffect !&#x3D;&#x3D; null) &#123;</span><br><span class="line">          if (returnFiber.lastEffect !&#x3D;&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; next</span><br><span class="line">            returnFiber.lastEffect.nextEffect &#x3D; workInProgress.firstEffect;</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F; last</span><br><span class="line">          returnFiber.lastEffect &#x3D; workInProgress.lastEffect;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 获取副作用标记</span><br><span class="line">        &#x2F;&#x2F; 初始渲染时除[根组件]以外的 Fiber, effectTag 值都为 0, 即不需要执行任何真实DOM操作</span><br><span class="line">        &#x2F;&#x2F; 根组件的 effectTag 值为 3, 即需要将此节点对应的真实DOM对象添加到页面中</span><br><span class="line">        const effectTag &#x3D; workInProgress.effectTag;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 创建 effect 列表时跳过 NoWork(0) 和 PerformedWork(1) 标记</span><br><span class="line">        &#x2F;&#x2F; PerformedWork 由 React DevTools 读取, 不提交</span><br><span class="line">        &#x2F;&#x2F; 初始渲染时 只有遍历到了根组件 判断条件才能成立, 将 effect 链表添加到 rootFiber</span><br><span class="line">        &#x2F;&#x2F; 初始渲染 FiberRoot 对象中的 firstEffect 和 lastEffect 都是 App 组件</span><br><span class="line">        &#x2F;&#x2F; 因为当所有节点在内存中构建完成后, 只需要一次将所有 DOM 添加到页面中</span><br><span class="line">        if (effectTag &gt; PerformedWork) &#123;</span><br><span class="line">          &#x2F;&#x2F; false</span><br><span class="line">          if (returnFiber.lastEffect !&#x3D;&#x3D; null) &#123;</span><br><span class="line">            returnFiber.lastEffect.nextEffect &#x3D; workInProgress;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 为 fiberRoot 添加 firstEffect</span><br><span class="line">            returnFiber.firstEffect &#x3D; workInProgress;</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F; 为 fiberRoot 添加 lastEffect</span><br><span class="line">          returnFiber.lastEffect &#x3D; workInProgress;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    	&#x2F;&#x2F; 忽略了初始渲染不执行的代码      </span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 获取下一个同级 Fiber 对象</span><br><span class="line">    const siblingFiber &#x3D; workInProgress.sibling;</span><br><span class="line">    &#x2F;&#x2F; 如果下一个同级 Fiber 对象存在</span><br><span class="line">    if (siblingFiber !&#x3D;&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 返回下一个同级 Fiber 对象</span><br><span class="line">      return siblingFiber;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 否则退回父级</span><br><span class="line">    workInProgress &#x3D; returnFiber;</span><br><span class="line">  &#125; while (workInProgress !&#x3D;&#x3D; null);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 当执行到这里的时候, 说明遍历到了 root 节点, 已完成遍历</span><br><span class="line">  &#x2F;&#x2F; 更新 workInProgressRootExitStatus 的状态为 已完成</span><br><span class="line">  if (workInProgressRootExitStatus &#x3D;&#x3D;&#x3D; RootIncomplete) &#123;</span><br><span class="line">    workInProgressRootExitStatus &#x3D; RootCompleted;</span><br><span class="line">  &#125;</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>completeWork</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactFiberCompleteWork.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">function completeWork(</span><br><span class="line">  current: Fiber | null,</span><br><span class="line">  workInProgress: Fiber,</span><br><span class="line">  renderExpirationTime: ExpirationTime,</span><br><span class="line">): Fiber | null &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取待更新 props</span><br><span class="line">  const newProps &#x3D; workInProgress.pendingProps;</span><br><span class="line">  switch (workInProgress.tag) &#123;</span><br><span class="line">    &#x2F;&#x2F; 0</span><br><span class="line">    case FunctionComponent:</span><br><span class="line">      return null;</span><br><span class="line">    &#x2F;&#x2F; 3</span><br><span class="line">    case HostRoot: &#123;</span><br><span class="line">      updateHostContainer(workInProgress);</span><br><span class="line">      return null;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 5</span><br><span class="line">    case HostComponent: &#123;</span><br><span class="line">      &#x2F;&#x2F; 获取 rootDOM 节点 &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">      const rootContainerInstance &#x3D; getRootHostContainer();</span><br><span class="line">      &#x2F;&#x2F; 节点的具体的类型 div span ...</span><br><span class="line">      const type &#x3D; workInProgress.type;</span><br><span class="line">      &#x2F;&#x2F; false current &#x3D; null</span><br><span class="line">      if (current !&#x3D;&#x3D; null &amp;&amp; workInProgress.stateNode !&#x3D; null) &#123;</span><br><span class="line">       &#x2F;&#x2F; 初始渲染不执行</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">				&#x2F;&#x2F; false</span><br><span class="line">        if (wasHydrated) &#123;</span><br><span class="line">         &#x2F;&#x2F; 初始渲染不执行</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          &#x2F;&#x2F; 创建节点实例对象 &lt;div&gt;&lt;&#x2F;div&gt; &lt;span&gt;&lt;&#x2F;span&gt;</span><br><span class="line">          let instance &#x3D; createInstance(</span><br><span class="line">            type,</span><br><span class="line">            newProps,</span><br><span class="line">            rootContainerInstance,</span><br><span class="line">            currentHostContext,</span><br><span class="line">            workInProgress,</span><br><span class="line">          );</span><br><span class="line">          &#x2F;**</span><br><span class="line">           * 将所有的子级追加到父级中</span><br><span class="line">           * instance 为父级</span><br><span class="line">           * workInProgress.child 为子级</span><br><span class="line">           *&#x2F;</span><br><span class="line">          appendAllChildren(instance, workInProgress, false, false);</span><br><span class="line">          &#x2F;&#x2F; 为 Fiber 对象添加 stateNode 属性</span><br><span class="line">          workInProgress.stateNode &#x3D; instance;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 处理 ref DOM 引用</span><br><span class="line">        if (workInProgress.ref !&#x3D;&#x3D; null) &#123;</span><br><span class="line">          markRef(workInProgress);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>appendAllChildren</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactFiberCompleteWork.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">appendAllChildren &#x3D; function (</span><br><span class="line">    parent: Instance,</span><br><span class="line">    workInProgress: Fiber,</span><br><span class="line">    needsVisibilityToggle: boolean,</span><br><span class="line">    isHidden: boolean,</span><br><span class="line">  ) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取子级</span><br><span class="line">    let node &#x3D; workInProgress.child;</span><br><span class="line">    &#x2F;&#x2F; 如果子级不为空 执行循环</span><br><span class="line">    while (node !&#x3D;&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果 node 是普通 ReactElement 或者为文本</span><br><span class="line">      if (node.tag &#x3D;&#x3D;&#x3D; HostComponent || node.tag &#x3D;&#x3D;&#x3D; HostText) &#123;</span><br><span class="line">        &#x2F;&#x2F; 将子级追加到父级中</span><br><span class="line">        appendInitialChild(parent, node.stateNode);</span><br><span class="line">      &#125; else if (node.child !&#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果 node 不是普通 ReactElement 又不是文本</span><br><span class="line">        &#x2F;&#x2F; 将 node 视为组件, 组件本身不能转换为真实 DOM 元素</span><br><span class="line">        &#x2F;&#x2F; 获取到组件的第一个子元素, 继续执行循环</span><br><span class="line">        node.child.return &#x3D; node;</span><br><span class="line">        node &#x3D; node.child;</span><br><span class="line">        continue;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 如果 node 和 workInProgress 是同一个节点</span><br><span class="line">      &#x2F;&#x2F; 说明 node 已经退回到父级 终止循环</span><br><span class="line">      &#x2F;&#x2F; 说明此时所有子级都已经追加到父级中了</span><br><span class="line">      if (node &#x3D;&#x3D;&#x3D; workInProgress) &#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 处理子级节点的兄弟节点</span><br><span class="line">      while (node.sibling &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果节点没有父级或者节点的父级是自己, 退出循环</span><br><span class="line">        &#x2F;&#x2F; 说明此时所有子级都已经追加到父级中了</span><br><span class="line">        if (node.return &#x3D;&#x3D;&#x3D; null || node.return &#x3D;&#x3D;&#x3D; workInProgress) &#123;</span><br><span class="line">          return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 更新 node</span><br><span class="line">        node &#x3D; node.return;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 更新父级 方便回退</span><br><span class="line">      node.sibling.return &#x3D; node.return;</span><br><span class="line">      &#x2F;&#x2F; 将 node 更新为下一个兄弟节点</span><br><span class="line">      node &#x3D; node.sibling;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="21-从render阶段进入commit阶段"><a href="#21-从render阶段进入commit阶段" class="headerlink" title="21.从render阶段进入commit阶段"></a>21.从render阶段进入commit阶段</h3><blockquote>
<p>finishSyncRender</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactFiberWorkLoop.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function finishSyncRender(root) &#123;</span><br><span class="line">  &#x2F;&#x2F; 销毁 workInProgress Fiber 树</span><br><span class="line">  &#x2F;&#x2F; 因为待提交 Fiber 对象已经被存储在了 root.finishedWork 中</span><br><span class="line">  workInProgressRoot &#x3D; null;</span><br><span class="line">  &#x2F;&#x2F; 进入 commit 阶段</span><br><span class="line">  commitRoot(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>commitRoot</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactFiberWorkLoop.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function commitRoot(root) &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取任务优先级 97 &#x3D;&gt; 普通优先级</span><br><span class="line">  const renderPriorityLevel &#x3D; getCurrentPriorityLevel();</span><br><span class="line">  &#x2F;&#x2F; 使用最高优先级执行当前任务, 因为 commit 阶段不可以被打断</span><br><span class="line">  &#x2F;&#x2F; ImmediatePriority, 优先级为 99, 最高优先级</span><br><span class="line">  runWithPriority(</span><br><span class="line">    ImmediatePriority,</span><br><span class="line">    commitRootImpl.bind(null, root, renderPriorityLevel),</span><br><span class="line">  );</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>commitRootImpl</p>
</blockquote>
<p>commit 阶段可以分为三个子阶段：</p>
<ul>
<li>before mutation 阶段（执行 DOM 操作前）</li>
<li>mutation 阶段（执行 DOM 操作）</li>
<li>layout 阶段（执行 DOM 操作后）</li>
</ul>
<p><code>文件位置: packages/react-reconciler/src/ReactFiberWorkLoop.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">function commitRootImpl(root, renderPriorityLevel) &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取待提交 Fiber 对象 rootFiber</span><br><span class="line">  const finishedWork &#x3D; root.finishedWork;</span><br><span class="line">  &#x2F;&#x2F; 如果没有任务要执行</span><br><span class="line">  if (finishedWork &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 阻止程序继续向下执行</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 重置为默认值</span><br><span class="line">  root.finishedWork &#x3D; null;</span><br><span class="line">  root.callbackNode &#x3D; null;</span><br><span class="line">  root.callbackExpirationTime &#x3D; NoWork;</span><br><span class="line">  root.callbackPriority &#x3D; NoPriority;</span><br><span class="line">  root.nextKnownPendingLevel &#x3D; NoWork;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 获取要执行 DOM 操作的副作用列表</span><br><span class="line">  let firstEffect &#x3D; finishedWork.firstEffect;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; true</span><br><span class="line">  if (firstEffect !&#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; commit 第一个子阶段</span><br><span class="line">    nextEffect &#x3D; firstEffect;</span><br><span class="line">    &#x2F;&#x2F; 处理类组件的 getSnapShotBeforeUpdate 生命周期函数</span><br><span class="line">    do &#123;</span><br><span class="line">      invokeGuardedCallback(null, commitBeforeMutationEffects, null);</span><br><span class="line">    &#125; while (nextEffect !&#x3D;&#x3D; null);</span><br><span class="line">    </span><br><span class="line">		&#x2F;&#x2F; commit 第二个子阶段</span><br><span class="line">    nextEffect &#x3D; firstEffect;</span><br><span class="line">    do &#123;</span><br><span class="line">      invokeGuardedCallback(null, commitMutationEffects, null, root, renderPriorityLevel);</span><br><span class="line">    &#125; while (nextEffect !&#x3D;&#x3D; null);</span><br><span class="line">    &#x2F;&#x2F; 将 workInProgress Fiber 树变成 current Fiber 树</span><br><span class="line">    root.current &#x3D; finishedWork;</span><br><span class="line">    </span><br><span class="line">		&#x2F;&#x2F; commit 第三个子阶段</span><br><span class="line">    nextEffect &#x3D; firstEffect;</span><br><span class="line">    do &#123;</span><br><span class="line">      invokeGuardedCallback(null, commitLayoutEffects, null, root,expirationTime);</span><br><span class="line">    &#125; while (nextEffect !&#x3D;&#x3D; null);</span><br><span class="line">		</span><br><span class="line">    &#x2F;&#x2F; 重置 nextEffect</span><br><span class="line">    nextEffect &#x3D; null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="22-commit阶段的第一个子阶段"><a href="#22-commit阶段的第一个子阶段" class="headerlink" title="22.commit阶段的第一个子阶段"></a>22.commit阶段的第一个子阶段</h3><blockquote>
<p>commitBeforeMutationEffects</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactFiberWorkLoop.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; commit 阶段的第一个子阶段</span><br><span class="line">&#x2F;&#x2F; 调用类组件的 getSnapshotBeforeUpdate 生命周期函数</span><br><span class="line">function commitBeforeMutationEffects() &#123;</span><br><span class="line">  &#x2F;&#x2F; 循环 effect 链</span><br><span class="line">  while (nextEffect !&#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; nextEffect 是 effect 链上从 firstEffect 到 lastEffec 的每一个需要commit的 fiber 对象</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 初始化渲染第一个 nextEffect 为 App 组件</span><br><span class="line">    &#x2F;&#x2F; effectTag &#x3D;&gt; 3</span><br><span class="line">    const effectTag &#x3D; nextEffect.effectTag;</span><br><span class="line">    &#x2F;&#x2F; console.log(effectTag);</span><br><span class="line">    &#x2F;&#x2F; nextEffect &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; return;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 如果 fiber 对象中里有 Snapshot 这个 effectTag 的话</span><br><span class="line">    &#x2F;&#x2F; Snapshot 和更新有关系 初始化渲染 不执行</span><br><span class="line">    &#x2F;&#x2F; false</span><br><span class="line">    if ((effectTag &amp; Snapshot) !&#x3D;&#x3D; NoEffect) &#123;</span><br><span class="line">      &#x2F;&#x2F; 获取当前 fiber 节点</span><br><span class="line">      const current &#x3D; nextEffect.alternate;</span><br><span class="line">      &#x2F;&#x2F; 当 nextEffect 上有 Snapshot 这个 effectTag 时</span><br><span class="line">      &#x2F;&#x2F; 执行以下方法, 主要是类组件调用 getSnapshotBeforeUpdate 生命周期函数</span><br><span class="line">      commitBeforeMutationEffectOnFiber(current, nextEffect);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 更新循环条件</span><br><span class="line">    nextEffect &#x3D; nextEffect.nextEffect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>commitBeforeMutationLifeCycles</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactFiberCommitWork.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">function commitBeforeMutationLifeCycles(</span><br><span class="line">  current: Fiber | null,</span><br><span class="line">  finishedWork: Fiber,</span><br><span class="line">): void &#123;</span><br><span class="line">  switch (finishedWork.tag) &#123;</span><br><span class="line">    case FunctionComponent:</span><br><span class="line">    case ForwardRef:</span><br><span class="line">    case SimpleMemoComponent:</span><br><span class="line">    case Block: &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果该 fiber 类型是 ClassComponent</span><br><span class="line">    case ClassComponent: &#123;</span><br><span class="line">      if (finishedWork.effectTag &amp; Snapshot) &#123;</span><br><span class="line">        if (current !&#x3D;&#x3D; null) &#123;</span><br><span class="line">          &#x2F;&#x2F; 旧的 props</span><br><span class="line">          const prevProps &#x3D; current.memoizedProps;</span><br><span class="line">          &#x2F;&#x2F; 旧的 state</span><br><span class="line">          const prevState &#x3D; current.memoizedState;</span><br><span class="line">          &#x2F;&#x2F; 获取 classComponent 组件的实例对象</span><br><span class="line">          const instance &#x3D; finishedWork.stateNode;</span><br><span class="line">          &#x2F;&#x2F; 执行 getSnapshotBeforeUpdate 生命周期函数</span><br><span class="line">          &#x2F;&#x2F; 在组件更新前捕获一些 DOM 信息</span><br><span class="line">          &#x2F;&#x2F; 返回自定义的值或 null, 统称为 snapshot</span><br><span class="line">          const snapshot &#x3D; instance.getSnapshotBeforeUpdate(</span><br><span class="line">            finishedWork.elementType &#x3D;&#x3D;&#x3D; finishedWork.type</span><br><span class="line">              ? prevProps</span><br><span class="line">              : resolveDefaultProps(finishedWork.type, prevProps),</span><br><span class="line">            prevState,</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    case HostRoot:</span><br><span class="line">    case HostComponent:</span><br><span class="line">    case HostText:</span><br><span class="line">    case HostPortal:</span><br><span class="line">    case IncompleteClassComponent:</span><br><span class="line">      &#x2F;&#x2F; Nothing to do for these component types</span><br><span class="line">      return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23-commit阶段的第二个子阶段"><a href="#23-commit阶段的第二个子阶段" class="headerlink" title="23.commit阶段的第二个子阶段"></a>23.commit阶段的第二个子阶段</h3><blockquote>
<p>commitMutationEffects</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactFiberWorkLoop.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; commit 阶段的第二个子阶段</span><br><span class="line">&#x2F;&#x2F; 根据 effectTag 执行 DOM 操作</span><br><span class="line">function commitMutationEffects(root: FiberRoot, renderPriorityLevel) &#123;</span><br><span class="line">  &#x2F;&#x2F; 循环 effect 链</span><br><span class="line">  while (nextEffect !&#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取 effectTag</span><br><span class="line">    &#x2F;&#x2F; 初始渲染第一次循环为 App 组件</span><br><span class="line">    &#x2F;&#x2F; 即将根组件及内部所有内容一次性添加到页面中</span><br><span class="line">    const effectTag &#x3D; nextEffect.effectTag;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 根据 effectTag 分别处理</span><br><span class="line">    let primaryEffectTag &#x3D;</span><br><span class="line">      effectTag &amp; (Placement | Update | Deletion | Hydrating);</span><br><span class="line">    &#x2F;&#x2F; 匹配 effectTag</span><br><span class="line">    &#x2F;&#x2F; 初始渲染 primaryEffectTag 为 2 匹配到 Placement</span><br><span class="line">    switch (primaryEffectTag) &#123;</span><br><span class="line">      &#x2F;&#x2F; 针对该节点及子节点进行插入操作</span><br><span class="line">      case Placement: &#123;</span><br><span class="line">        commitPlacement(nextEffect);</span><br><span class="line">        &#x2F;&#x2F; effectTag 从 3 变为 1</span><br><span class="line">        &#x2F;&#x2F; 从 effect 标签中清除 &quot;placement&quot; 重置 effectTag 值</span><br><span class="line">        &#x2F;&#x2F; 以便我们知道在调用诸如componentDidMount之类的任何生命周期之前已将其插入。</span><br><span class="line">        nextEffect.effectTag &amp;&#x3D; ~Placement;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 插入并更新 DOM</span><br><span class="line">      case PlacementAndUpdate: &#123;</span><br><span class="line">        &#x2F;&#x2F; 插入</span><br><span class="line">        commitPlacement(nextEffect);</span><br><span class="line">        nextEffect.effectTag &amp;&#x3D; ~Placement;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 更新</span><br><span class="line">        const current &#x3D; nextEffect.alternate;</span><br><span class="line">        commitWork(current, nextEffect);</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 服务器端渲染</span><br><span class="line">      case Hydrating: &#123;</span><br><span class="line">        nextEffect.effectTag &amp;&#x3D; ~Hydrating;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 服务器端渲染</span><br><span class="line">      case HydratingAndUpdate: &#123;</span><br><span class="line">        nextEffect.effectTag &amp;&#x3D; ~Hydrating;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Update</span><br><span class="line">        const current &#x3D; nextEffect.alternate;</span><br><span class="line">        commitWork(current, nextEffect);</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 更新 DOM</span><br><span class="line">      case Update: &#123;</span><br><span class="line">        const current &#x3D; nextEffect.alternate;</span><br><span class="line">        commitWork(current, nextEffect);</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 删除 DOM</span><br><span class="line">      case Deletion: &#123;</span><br><span class="line">        commitDeletion(root, nextEffect, renderPriorityLevel);</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nextEffect &#x3D; nextEffect.nextEffect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>commitPlacement</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactFiberCommitWork.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 挂载 DOM 元素</span><br><span class="line">function commitPlacement(finishedWork: Fiber): void &#123;</span><br><span class="line">  &#x2F;&#x2F; finishedWork 初始化渲染时为根组件 Fiber 对象</span><br><span class="line">  &#x2F;&#x2F; 获取非组件父级 Fiber 对象</span><br><span class="line">  &#x2F;&#x2F; 初始渲染时为 &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  const parentFiber &#x3D; getHostParentFiber(finishedWork);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 存储真正的父级 DOM 节点对象</span><br><span class="line">  let parent;</span><br><span class="line">  &#x2F;&#x2F; 是否为渲染容器</span><br><span class="line">  &#x2F;&#x2F; 渲染容器和普通react元素的主要区别在于是否需要特殊处理注释节点</span><br><span class="line">  let isContainer;</span><br><span class="line">  &#x2F;&#x2F; 获取父级 DOM 节点对象</span><br><span class="line">  &#x2F;&#x2F; 但是初始渲染时 rootFiber 对象中的 stateNode 存储的是 FiberRoot</span><br><span class="line">  const parentStateNode &#x3D; parentFiber.stateNode;</span><br><span class="line">  &#x2F;&#x2F; 判断父节点的类型</span><br><span class="line">  &#x2F;&#x2F; 初始渲染时是 hostRoot 3</span><br><span class="line">  switch (parentFiber.tag) &#123;</span><br><span class="line">    case HostComponent:</span><br><span class="line">      parent &#x3D; parentStateNode;</span><br><span class="line">      isContainer &#x3D; false;</span><br><span class="line">      break;</span><br><span class="line">    case HostRoot:</span><br><span class="line">      &#x2F;&#x2F; 获取真正的 DOM 节点对象</span><br><span class="line">      &#x2F;&#x2F; &lt;div id&#x3D;&quot;root&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">      parent &#x3D; parentStateNode.containerInfo;</span><br><span class="line">      &#x2F;&#x2F; 是 container 容器</span><br><span class="line">      isContainer &#x3D; true;</span><br><span class="line">      break;</span><br><span class="line">    case HostPortal:</span><br><span class="line">      parent &#x3D; parentStateNode.containerInfo;</span><br><span class="line">      isContainer &#x3D; true;</span><br><span class="line">      break;</span><br><span class="line">    case FundamentalComponent:</span><br><span class="line">      if (enableFundamentalAPI) &#123;</span><br><span class="line">        parent &#x3D; parentStateNode.instance;</span><br><span class="line">        isContainer &#x3D; false;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 查看当前节点是否有下一个兄弟节点</span><br><span class="line">  &#x2F;&#x2F; 有, 执行 insertBefore</span><br><span class="line">  &#x2F;&#x2F; 没有, 执行 appendChild</span><br><span class="line">  const before &#x3D; getHostSibling(finishedWork);</span><br><span class="line">	&#x2F;&#x2F; 渲染容器</span><br><span class="line">  if (isContainer) &#123;</span><br><span class="line">    &#x2F;&#x2F; 向父节点中追加节点 或者 将子节点插入到 before 节点的前面</span><br><span class="line">    insertOrAppendPlacementNodeIntoContainer(finishedWork, before, parent);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 非渲染容器</span><br><span class="line">    &#x2F;&#x2F; 向父节点中追加节点 或者 将子节点插入到 before 节点的前面</span><br><span class="line">    insertOrAppendPlacementNode(finishedWork, before, parent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>getHostParentFiber</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactFiberCommitWork.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取 HostRootFiber 对象</span><br><span class="line">function getHostParentFiber(fiber: Fiber): Fiber &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取当前 Fiber 父级</span><br><span class="line">  let parent &#x3D; fiber.return;</span><br><span class="line">  &#x2F;&#x2F; 查看父级是否为 null</span><br><span class="line">  while (parent !&#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 查看父级是否为 hostRoot</span><br><span class="line">    if (isHostParent(parent)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 返回</span><br><span class="line">      return parent;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 继续向上查找</span><br><span class="line">    parent &#x3D; parent.return;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>insertOrAppendPlacementNodeIntoContainer</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactFiberCommitWork.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 向容器中追加 | 插入到某一个节点的前面</span><br><span class="line">function insertOrAppendPlacementNodeIntoContainer(</span><br><span class="line">  node: Fiber,</span><br><span class="line">  before: ?Instance,</span><br><span class="line">  parent: Container,</span><br><span class="line">): void &#123;</span><br><span class="line">  const &#123;tag&#125; &#x3D; node;</span><br><span class="line">  &#x2F;&#x2F; 如果待插入的节点是一个 DOM 元素或者文本的话</span><br><span class="line">  &#x2F;&#x2F; 比如 组件fiber &#x3D;&gt; false div &#x3D;&gt; true</span><br><span class="line">  const isHost &#x3D; tag &#x3D;&#x3D;&#x3D; HostComponent || tag &#x3D;&#x3D;&#x3D; HostText;</span><br><span class="line"></span><br><span class="line">  if (isHost || (enableFundamentalAPI &amp;&amp; tag &#x3D;&#x3D;&#x3D; FundamentalComponent)) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取 DOM 节点</span><br><span class="line">    const stateNode &#x3D; isHost ? node.stateNode : node.stateNode.instance;</span><br><span class="line">    &#x2F;&#x2F; 如果 before 存在</span><br><span class="line">    if (before) &#123;</span><br><span class="line">      &#x2F;&#x2F; 插入到 before 前面</span><br><span class="line">      insertInContainerBefore(parent, stateNode, before);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 追加到父容器中</span><br><span class="line">      appendChildToContainer(parent, stateNode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果是组件节点, 比如 ClassComponent, 则找它的第一个子节点(DOM 元素)</span><br><span class="line">    &#x2F;&#x2F; 进行插入操作</span><br><span class="line">    const child &#x3D; node.child;</span><br><span class="line">    if (child !&#x3D;&#x3D; null) &#123;</span><br><span class="line">      &#x2F;&#x2F; 向父级中追加子节点或者将子节点插入到 before 的前面</span><br><span class="line">      insertOrAppendPlacementNodeIntoContainer(child, before, parent);</span><br><span class="line">      &#x2F;&#x2F; 获取下一个兄弟节点</span><br><span class="line">      let sibling &#x3D; child.sibling;</span><br><span class="line">      &#x2F;&#x2F; 如果兄弟节点存在</span><br><span class="line">      while (sibling !&#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 向父级中追加子节点或者将子节点插入到 before 的前面</span><br><span class="line">        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);</span><br><span class="line">        &#x2F;&#x2F; 同步兄弟节点</span><br><span class="line">        sibling &#x3D; sibling.sibling;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>insertInContainerBefore</p>
</blockquote>
<p><code>文件位置: packages/react-dom/src/client/ReactDOMHostConfig.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export function insertInContainerBefore(</span><br><span class="line">  container: Container,</span><br><span class="line">  child: Instance | TextInstance,</span><br><span class="line">  beforeChild: Instance | TextInstance | SuspenseInstance,</span><br><span class="line">): void &#123;</span><br><span class="line">  &#x2F;&#x2F; 如果父容器是注释节点</span><br><span class="line">  if (container.nodeType &#x3D;&#x3D;&#x3D; COMMENT_NODE) &#123;</span><br><span class="line">    &#x2F;&#x2F; 找到注释节点的父级节点 因为注释节点没法调用 insertBefore</span><br><span class="line">    (container.parentNode: any).insertBefore(child, beforeChild);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 将 child 插入到 beforeChild 的前面</span><br><span class="line">    container.insertBefore(child, beforeChild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>appendChildToContainer</p>
</blockquote>
<p><code>文件位置: packages/react-dom/src/client/ReactDOMHostConfig.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">export function appendChildToContainer(</span><br><span class="line">  container: Container,</span><br><span class="line">  child: Instance | TextInstance,</span><br><span class="line">): void &#123;</span><br><span class="line">  &#x2F;&#x2F; 监测 container 是否注释节点</span><br><span class="line">  if (container.nodeType &#x3D;&#x3D;&#x3D; COMMENT_NODE) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取父级的父级</span><br><span class="line">    parentNode &#x3D; (container.parentNode: any);</span><br><span class="line">    &#x2F;&#x2F; 将子级节点插入到注释节点的前面</span><br><span class="line">    parentNode.insertBefore(child, container);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 直接将 child 插入到父级中</span><br><span class="line">    parentNode &#x3D; container;</span><br><span class="line">    parentNode.appendChild(child);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="24-commit阶段的第三个子阶段-一"><a href="#24-commit阶段的第三个子阶段-一" class="headerlink" title="24.commit阶段的第三个子阶段(一)"></a>24.commit阶段的第三个子阶段(一)</h3><blockquote>
<p>commitLayoutEffects</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactFiberWorkLoop.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; commit 阶段的第三个子阶段</span><br><span class="line">function commitLayoutEffects(</span><br><span class="line">  root: FiberRoot,</span><br><span class="line">  committedExpirationTime: ExpirationTime,</span><br><span class="line">) &#123;</span><br><span class="line">  while (nextEffect !&#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 此时 effectTag 已经被重置为 1, 表示 DOM 操作已经完成</span><br><span class="line">    const effectTag &#x3D; nextEffect.effectTag;</span><br><span class="line">    &#x2F;&#x2F; 调用生命周期函数和钩子函数</span><br><span class="line">    &#x2F;&#x2F; 前提是类组件中调用了生命周期函数 或者函数组件中调用了 useEffect</span><br><span class="line">    if (effectTag &amp; (Update | Callback)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 类组件处理生命周期函数</span><br><span class="line">      &#x2F;&#x2F; 函数组件处理钩子函数</span><br><span class="line">      commitLayoutEffectOnFiber(root, current,nextEffect, committedExpirationTime);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 更新循环条件</span><br><span class="line">    nextEffect &#x3D; nextEffect.nextEffect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>commitLifeCycles</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactFiberCommitWork.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">function commitLifeCycles(</span><br><span class="line">  finishedRoot: FiberRoot,</span><br><span class="line">  current: Fiber | null,</span><br><span class="line">  finishedWork: Fiber,</span><br><span class="line">  committedExpirationTime: ExpirationTime,</span><br><span class="line">): void &#123;</span><br><span class="line">  switch (finishedWork.tag) &#123;</span><br><span class="line">    case FunctionComponent: &#123;</span><br><span class="line">      &#x2F;&#x2F; 处理钩子函数</span><br><span class="line">      commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    case ClassComponent: &#123;</span><br><span class="line">      &#x2F;&#x2F; 获取类组件实例对象</span><br><span class="line">      const instance &#x3D; finishedWork.stateNode;</span><br><span class="line">      &#x2F;&#x2F; 如果在类组件中存在生命周期函数判断条件就会成立</span><br><span class="line">      if (finishedWork.effectTag &amp; Update) &#123;</span><br><span class="line">        &#x2F;&#x2F; 初始渲染阶段</span><br><span class="line">        if (current &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">          &#x2F;&#x2F; 调用 componentDidMount 生命周期函数</span><br><span class="line">          instance.componentDidMount();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          &#x2F;&#x2F; 更新阶段</span><br><span class="line">          &#x2F;&#x2F; 获取旧的 props</span><br><span class="line">          const prevProps &#x3D; finishedWork.elementType &#x3D;&#x3D;&#x3D; finishedWork.type</span><br><span class="line">              ? current.memoizedProps</span><br><span class="line">              : resolveDefaultProps(finishedWork.type, current.memoizedProps);</span><br><span class="line">          &#x2F;&#x2F; 获取旧的 state</span><br><span class="line">          const prevState &#x3D; current.memoizedState;</span><br><span class="line">          &#x2F;&#x2F; 调用 componentDidUpdate 生命周期函数</span><br><span class="line">          &#x2F;&#x2F; instance.__reactInternalSnapshotBeforeUpdate 快照 getSnapShotBeforeUpdate 方法的返回值</span><br><span class="line">          instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 获取任务队列</span><br><span class="line">      const updateQueue &#x3D; finishedWork.updateQueue;</span><br><span class="line">      &#x2F;&#x2F; 如果任务队列存在</span><br><span class="line">      if (updateQueue !&#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 调用 ReactElement 渲染完成之后的回调函数</span><br><span class="line">         * 即 render 方法的第三个参数</span><br><span class="line">         *&#x2F;</span><br><span class="line">        commitUpdateQueue(finishedWork, updateQueue, instance);</span><br><span class="line">      &#125;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>commitUpdateQueue</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactUpdateQueue.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 执行渲染完成之后的回调函数</span><br><span class="line"> *&#x2F;</span><br><span class="line">export function commitUpdateQueue&lt;State&gt;(</span><br><span class="line">  finishedWork: Fiber,</span><br><span class="line">  finishedQueue: UpdateQueue&lt;State&gt;,</span><br><span class="line">  instance: any,</span><br><span class="line">): void &#123;</span><br><span class="line">  &#x2F;&#x2F; effects 为数组, 存储任务对象 (Update 对象)</span><br><span class="line">  &#x2F;&#x2F; 但前提是在调用 render 方法时传递了回调函数, 就是 render 方法的第三个参数</span><br><span class="line">  const effects &#x3D; finishedQueue.effects;</span><br><span class="line">  &#x2F;&#x2F; 重置 finishedQueue.effects 数组</span><br><span class="line">  finishedQueue.effects &#x3D; null;</span><br><span class="line">  &#x2F;&#x2F; 如果传递了 render 方法的第三个参数, effect 数组就不会为 null</span><br><span class="line">  if (effects !&#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 遍历 effect 数组</span><br><span class="line">    for (let i &#x3D; 0; i &lt; effects.length; i++) &#123;</span><br><span class="line">      &#x2F;&#x2F; 获取数组中的第 i 个需要执行的 effect</span><br><span class="line">      const effect &#x3D; effects[i];</span><br><span class="line">      &#x2F;&#x2F; 获取 callback 回调函数</span><br><span class="line">      const callback &#x3D; effect.callback;</span><br><span class="line">      &#x2F;&#x2F; 如果回调函数不为 null</span><br><span class="line">      if (callback !&#x3D;&#x3D; null) &#123;</span><br><span class="line">        &#x2F;&#x2F; 清空 effect 中的 callback</span><br><span class="line">        effect.callback &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; 执行回调函数</span><br><span class="line">        callCallback(callback, instance);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>commitHookEffectListMount</p>
</blockquote>
<p><code>文件位置: packages/react-reconciler/src/ReactFiberCommitWork.js</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * useEffect 回调函数调用</span><br><span class="line"> *&#x2F;</span><br><span class="line">function commitHookEffectListMount(tag: number, finishedWork: Fiber) &#123;</span><br><span class="line">  &#x2F;&#x2F; 获取任务队列</span><br><span class="line">  const updateQueue: FunctionComponentUpdateQueue | null &#x3D; (finishedWork.updateQueue: any);</span><br><span class="line">  &#x2F;&#x2F; 获取 lastEffect</span><br><span class="line">  let lastEffect &#x3D; updateQueue !&#x3D;&#x3D; null ? updateQueue.lastEffect : null;</span><br><span class="line">  &#x2F;&#x2F; 如果 lastEffect 不为 null</span><br><span class="line">  if (lastEffect !&#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取要执行的副作用</span><br><span class="line">    const firstEffect &#x3D; lastEffect.next;</span><br><span class="line">    let effect &#x3D; firstEffect;</span><br><span class="line">    &#x2F;&#x2F; 通过遍历的方式调用 useEffect 中的回调函数</span><br><span class="line">    &#x2F;&#x2F; 在组件中定义了调用了几次 useEffect 遍历就会执行几次</span><br><span class="line">    do &#123;</span><br><span class="line">      if ((effect.tag &amp; tag) &#x3D;&#x3D;&#x3D; tag) &#123;</span><br><span class="line">        &#x2F;&#x2F; Mount</span><br><span class="line">        const create &#x3D; effect.create;</span><br><span class="line">        &#x2F;&#x2F; create 就是 useEffect 方法的第一个参数</span><br><span class="line">        &#x2F;&#x2F; 返回值就是清理函数</span><br><span class="line">        effect.destroy &#x3D; create();</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 更新循环条件</span><br><span class="line">      effect &#x3D; effect.next;</span><br><span class="line">    &#125; while (effect !&#x3D;&#x3D; firstEffect);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="25-commit阶段的第三个子阶段-二"><a href="#25-commit阶段的第三个子阶段-二" class="headerlink" title="25.commit阶段的第三个子阶段(二)"></a>25.commit阶段的第三个子阶段(二)</h3>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScipt/" rel="tag"># JavaScipt</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/02/16/36/" rel="next" title="学习笔记 ----- 【Vue.js 框架源码与进阶】Vue.js + Vuex + TypeScript 实战项目开发与项目优化">
                <i class="fa fa-chevron-left"></i> 学习笔记 ----- 【Vue.js 框架源码与进阶】Vue.js + Vuex + TypeScript 实战项目开发与项目优化
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/02/22/37/" rel="prev" title="nrm报错 [ERR_INVALID_ARG_TYPE] 解决方法">
                nrm报错 [ERR_INVALID_ARG_TYPE] 解决方法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="FY" />
            
              <p class="site-author-name" itemprop="name">FY</p>
              <p class="site-description motion-element" itemprop="description">Just Be Yourself</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">48</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/xuanfeiyu" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Part-4-·-React-框架原理与实战"><span class="nav-number">1.</span> <span class="nav-text">Part 4 · React 框架原理与实战</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#模块一-·-React-设计原理解密及核心源码解读"><span class="nav-number">1.1.</span> <span class="nav-text">模块一 · React 设计原理解密及核心源码解读</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#任务一：React-基础回顾"><span class="nav-number">1.2.</span> <span class="nav-text">任务一：React 基础回顾</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-React-介绍"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.React 介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-JSX-语法回顾-一"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.JSX 语法回顾(一)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-JSX-语法回顾-二"><span class="nav-number">1.2.3.</span> <span class="nav-text">3.JSX 语法回顾(二)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-组件回顾-一"><span class="nav-number">1.2.4.</span> <span class="nav-text">4.组件回顾(一)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-组件回顾-二"><span class="nav-number">1.2.5.</span> <span class="nav-text">5.组件回顾(二)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-表单回顾"><span class="nav-number">1.2.6.</span> <span class="nav-text">6.表单回顾</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-路由回顾"><span class="nav-number">1.2.7.</span> <span class="nav-text">7.路由回顾</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#任务二：VirtualDOM-及-Diff-算法"><span class="nav-number">1.3.</span> <span class="nav-text">任务二：VirtualDOM 及 Diff 算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-课程介绍"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.课程介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-JSX-到底是什么"><span class="nav-number">1.3.2.</span> <span class="nav-text">2.JSX 到底是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-VirtualDOM-介绍"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.VirtualDOM 介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-创建-VirtualDOM-对象-一"><span class="nav-number">1.3.4.</span> <span class="nav-text">4.创建 VirtualDOM 对象(一)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-创建-VirtualDOM-对象-二"><span class="nav-number">1.3.5.</span> <span class="nav-text">5.创建 VirtualDOM 对象(二)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-普通-VirtualDOM-对象转化为真实-DOM-对象"><span class="nav-number">1.3.6.</span> <span class="nav-text">6.普通 VirtualDOM 对象转化为真实 DOM 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-为-DOM-对象添加属性"><span class="nav-number">1.3.7.</span> <span class="nav-text">7.为 DOM 对象添加属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-组件渲染之区分函数组件和类组件"><span class="nav-number">1.3.8.</span> <span class="nav-text">8.组件渲染之区分函数组件和类组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-组件渲染之函数组件"><span class="nav-number">1.3.9.</span> <span class="nav-text">9.组件渲染之函数组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-组件渲染之函数组件-prop-参数处理"><span class="nav-number">1.3.10.</span> <span class="nav-text">10.组件渲染之函数组件 prop 参数处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-组件渲染之类组件"><span class="nav-number">1.3.11.</span> <span class="nav-text">11.组件渲染之类组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-组件渲染之类组件-props-处理"><span class="nav-number">1.3.12.</span> <span class="nav-text">12.组件渲染之类组件 props 处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-更新-DOM-元素之-VirtualDOM-对比-节点类型相同的情况-一"><span class="nav-number">1.3.13.</span> <span class="nav-text">13.更新 DOM 元素之 VirtualDOM 对比(节点类型相同的情况)(一)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-更新-DOM-元素之-VirtualDOM-对比-节点类型相同的情况-二"><span class="nav-number">1.3.14.</span> <span class="nav-text">14.更新 DOM 元素之 VirtualDOM 对比(节点类型相同的情况)(二)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-图示-VirtualDOM-比对"><span class="nav-number">1.3.15.</span> <span class="nav-text">15.图示 VirtualDOM 比对</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-更新-DOM-元素之-VirtualDOM-对比-节点类型不相同的情况"><span class="nav-number">1.3.16.</span> <span class="nav-text">16.更新 DOM 元素之 VirtualDOM 对比(节点类型不相同的情况)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-更新-DOM-元素之删除节点"><span class="nav-number">1.3.17.</span> <span class="nav-text">17.更新 DOM 元素之删除节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-setState-方法实现类组件更新-一"><span class="nav-number">1.3.18.</span> <span class="nav-text">18.setState 方法实现类组件更新(一)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-setState-方法实现类组件更新-二"><span class="nav-number">1.3.19.</span> <span class="nav-text">19.setState 方法实现类组件更新(二)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-组件更新之不是同一个组件的情况"><span class="nav-number">1.3.20.</span> <span class="nav-text">20.组件更新之不是同一个组件的情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-组件更新之更新组件和旧组件是同一个组件的情况"><span class="nav-number">1.3.21.</span> <span class="nav-text">21.组件更新之更新组件和旧组件是同一个组件的情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-实现-ref-属性获取元素-DOM-对象获取组件实例对象"><span class="nav-number">1.3.22.</span> <span class="nav-text">22.实现 ref 属性获取元素 DOM 对象获取组件实例对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-使用-key-属性进行节点对比-一"><span class="nav-number">1.3.23.</span> <span class="nav-text">23.使用 key 属性进行节点对比(一)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-使用-key-属性进行节点对比-二"><span class="nav-number">1.3.24.</span> <span class="nav-text">24.使用 key 属性进行节点对比(二)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-删除节点-一"><span class="nav-number">1.3.25.</span> <span class="nav-text">25.删除节点(一)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-删除节点-二"><span class="nav-number">1.3.26.</span> <span class="nav-text">26.删除节点(二)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#任务三：Fiber"><span class="nav-number">1.4.</span> <span class="nav-text">任务三：Fiber</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-开发环境配置-一"><span class="nav-number">1.4.1.</span> <span class="nav-text">1.开发环境配置(一)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-开发环境配置-二"><span class="nav-number">1.4.2.</span> <span class="nav-text">2.开发环境配置(二)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-开发环境配置-三"><span class="nav-number">1.4.3.</span> <span class="nav-text">3.开发环境配置(三)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-requestIdleCallback-API-介绍及浏览器空余时间说明"><span class="nav-number">1.4.4.</span> <span class="nav-text">4.requestIdleCallback API 介绍及浏览器空余时间说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-requestIdleCallback使用方法"><span class="nav-number">1.4.5.</span> <span class="nav-text">5.requestIdleCallback使用方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-旧版Stack算法存在的问题以及新版Fiber解决方案介绍"><span class="nav-number">1.4.6.</span> <span class="nav-text">6.旧版Stack算法存在的问题以及新版Fiber解决方案介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-fiber算法实现思路以及fiber对象结构预览"><span class="nav-number">1.4.7.</span> <span class="nav-text">7.fiber算法实现思路以及fiber对象结构预览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-创建任务队列并添加任务"><span class="nav-number">1.4.8.</span> <span class="nav-text">8.创建任务队列并添加任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-实现任务的调度逻辑"><span class="nav-number">1.4.9.</span> <span class="nav-text">9.实现任务的调度逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-构建根节点Fiber对象"><span class="nav-number">1.4.10.</span> <span class="nav-text">10.构建根节点Fiber对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-构建子级节点Fiber对象"><span class="nav-number">1.4.11.</span> <span class="nav-text">11.构建子级节点Fiber对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-完善fiber对象-stateNode属性"><span class="nav-number">1.4.12.</span> <span class="nav-text">12.完善fiber对象-stateNode属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-完善fiber对象-tag属性"><span class="nav-number">1.4.13.</span> <span class="nav-text">13.完善fiber对象-tag属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-构建左侧节点树中的剩余子级节点Fiber对象"><span class="nav-number">1.4.14.</span> <span class="nav-text">14.构建左侧节点树中的剩余子级节点Fiber对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-构建剩余节点的fiber对象"><span class="nav-number">1.4.15.</span> <span class="nav-text">15.构建剩余节点的fiber对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-构建effects数组"><span class="nav-number">1.4.16.</span> <span class="nav-text">16.构建effects数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-fiber第二阶段-实现初始渲染"><span class="nav-number">1.4.17.</span> <span class="nav-text">17.fiber第二阶段-实现初始渲染</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-类组件处理"><span class="nav-number">1.4.18.</span> <span class="nav-text">18.类组件处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-处理函数组件"><span class="nav-number">1.4.19.</span> <span class="nav-text">19.处理函数组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-实现更新节点"><span class="nav-number">1.4.20.</span> <span class="nav-text">20.实现更新节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-扩展更新节点的方法"><span class="nav-number">1.4.21.</span> <span class="nav-text">21.扩展更新节点的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-实现节点删除操作"><span class="nav-number">1.4.22.</span> <span class="nav-text">22.实现节点删除操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-实现类组件状态更新功能"><span class="nav-number">1.4.23.</span> <span class="nav-text">23.实现类组件状态更新功能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#任务四：React-核心源码解读"><span class="nav-number">1.5.</span> <span class="nav-text">任务四：React 核心源码解读</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-搭建React源码本地调试环境"><span class="nav-number">1.5.1.</span> <span class="nav-text">1.搭建React源码本地调试环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-JSX转换为ReactElement的过程"><span class="nav-number">1.5.2.</span> <span class="nav-text">2.JSX转换为ReactElement的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-React检测开发者是否错误的使用了props属性"><span class="nav-number">1.5.3.</span> <span class="nav-text">3.React检测开发者是否错误的使用了props属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-isValidElement方法的内部实现"><span class="nav-number">1.5.4.</span> <span class="nav-text">4.isValidElement方法的内部实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-React16版本所采用的架构"><span class="nav-number">1.5.5.</span> <span class="nav-text">5.React16版本所采用的架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-Fiber数据结构介绍"><span class="nav-number">1.5.6.</span> <span class="nav-text">6.Fiber数据结构介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-双缓存技术介绍"><span class="nav-number">1.5.7.</span> <span class="nav-text">7.双缓存技术介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-区分fiberRoot和rootFiber"><span class="nav-number">1.5.8.</span> <span class="nav-text">8.区分fiberRoot和rootFiber</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-render方法解析"><span class="nav-number">1.5.9.</span> <span class="nav-text">9.render方法解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-创建fiberRoot对象和rootFiber对象"><span class="nav-number">1.5.10.</span> <span class="nav-text">10.创建fiberRoot对象和rootFiber对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-更改-callback-函数内部-this-指向"><span class="nav-number">1.5.11.</span> <span class="nav-text">11.更改 callback 函数内部 this 指向</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-创建任务并存放于任务队列"><span class="nav-number">1.5.12.</span> <span class="nav-text">12.创建任务并存放于任务队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-任务执行前的准备工作"><span class="nav-number">1.5.13.</span> <span class="nav-text">13.任务执行前的准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-构建workInProgress-Fiber-树中的rootFiber"><span class="nav-number">1.5.14.</span> <span class="nav-text">14.构建workInProgress Fiber 树中的rootFiber</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-workLoopSync方法解析"><span class="nav-number">1.5.15.</span> <span class="nav-text">15.workLoopSync方法解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-performUnitOfWork方法解析"><span class="nav-number">1.5.16.</span> <span class="nav-text">16.performUnitOfWork方法解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-构建单个子级Fiber对象的情况"><span class="nav-number">1.5.17.</span> <span class="nav-text">17.构建单个子级Fiber对象的情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-构建多个子级Fiber对象"><span class="nav-number">1.5.18.</span> <span class="nav-text">18.构建多个子级Fiber对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-子级节点Fiber对象的构建流程"><span class="nav-number">1.5.19.</span> <span class="nav-text">19.子级节点Fiber对象的构建流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-completeUnitOfWork方法解析"><span class="nav-number">1.5.20.</span> <span class="nav-text">20.completeUnitOfWork方法解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-从render阶段进入commit阶段"><span class="nav-number">1.5.21.</span> <span class="nav-text">21.从render阶段进入commit阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-commit阶段的第一个子阶段"><span class="nav-number">1.5.22.</span> <span class="nav-text">22.commit阶段的第一个子阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-commit阶段的第二个子阶段"><span class="nav-number">1.5.23.</span> <span class="nav-text">23.commit阶段的第二个子阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-commit阶段的第三个子阶段-一"><span class="nav-number">1.5.24.</span> <span class="nav-text">24.commit阶段的第三个子阶段(一)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#25-commit阶段的第三个子阶段-二"><span class="nav-number">1.5.25.</span> <span class="nav-text">25.commit阶段的第三个子阶段(二)</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FY</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
